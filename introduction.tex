%!TEX root = draft.tex
\section{Introduction}
\label{sec:introduction}

Efficient implementations of concurrent objects are essential and hard to get right. Verifying them is difficult, checking a single execution is NP-complete~\cite{journals/siamcomp/GibbonsK97} and checking a finite-state implementation is undecidable~\cite{conf/esop/BouajjaniEEH13}.

The set of objects considered in previous work consists of stacks, queues, registers.



Here, we consider another important object, the priority queues, which are essential for applications such as task scheduling and discrete event simulation, and for which numerous implementations have been proposed, e.g.,~\cite{DBLP:conf/ppopp/AlistarhKLS15,DBLP:conf/wdag/CalciuMH14,DBLP:conf/opodis/LindenJ13,DBLP:conf/podc/ShavitZ99,DBLP:conf/ipps/ShavitL00}. This object is much less studied compared to the other ones in the verification literature.

Priority queues are collections and in that sense, they could be found similar to stacks and queues. The main difference which complicates the process of inventing verification techniques is that the order in which elements are removed is not fixed by the happens-before like in stacks and queues but by parameters, the priorities, which come from an unbounded domain. TODO an example. Say that for generality, we consider partially-ordered priorities and that for single priority we take FIFO. In java, same priority values are removed in an arbitrary order, however, this can be modeled using our partial orders. TODO SAY HOW

Building on previous work~\cite{DBLP:conf/icalp/BouajjaniEEH15}, we define decision procedures for priority queues. These procedures are designed in several steps:
1) defining recursive procedures recognizing valid sequences, and extending them to concurrent executions. These procedures take values one by one and check some property local to that value, ignoring how operations on other values are ordered between them. This works only for data-differentiated, but this is complete by data-independence.
2) checking whether a fixed value violates that property can be done using a specific class of register automata, TODO say how simple they are
3) we distinguish between that value being removed or not, and we have to also consider the case of remove(empty). This results in 3-4 automata describing all the possible violations.

Although we follow the same schema as in~\cite{DBLP:conf/icalp/BouajjaniEEH15}, these results require establishing key results which are specific to priority queues and which are not implied by those for stacks and queues (say that more details are given in the related work)

This gives a reduction to reachability that works for arbitrary implementations, and a decision procedure for finite-state implementations




\smallskip

\noindent {\bf Related work}
\noindent The most related work of our paper is ~\cite{DBLP:conf/icalp/BouajjaniEEH15}. Compared to ~\cite{DBLP:conf/icalp/BouajjaniEEH15}, our work are specific to priority queue and thus have points not occur in queues and stacks. Due to the partial-order priorities, to prove the correctness of recursive procedure, we need to alter the positions of linearization points of incomparable items while keeps the linearization points of comparable items unchanged. {\color {blue}In the proof process we use the notion of left-right constraint, which is inspired by left-right constraint of queue \cite{Bouajjani:2015}.} For checking violations of one local property, we just need to find a value, such that at every possible time point to locate its remove operation, there is already values with smaller priorities in priority queue. For checking violations of another local property, we just need to find two values with maximal priority, such that every possible time point to locate remove operation of one value is disabled by remove operation of another value. Such phenomenons are unique for priority queue.



