%!TEX root = draft.tex
\section{Checking Inclusion By Recursive Procedure}
\label{sec:checking inclusion by recursive procedure}


 The projection $e \vert{O}$ of $e$ into $O$ is obtained from $e$ by erasing all call and return actions of non-$O$ operations. We write $e \setminus o$ for the projection $e \vert_{ O_e \setminus \{ o \} }$, where $O_e$ is the set of operations of $e$.

Given a data-differentiated sequential execution $e$, it is costly to check whether $e$ belongs to priority queue, since for each element of $e$, we should keep the current content of priority queue and try to modify the priority queue according to this element. Such process is too complex. In this section, we propose another method for checking inclusion of priority queue by using a recursive procedure $\textit{check-PQ}$. For checking a sequence, every time we only check a much simpler property, and then recursively check the remanning sequences obtained by erasing one or two elements. Each step of our method is easier to deal with.

$\textit{put}(a,p)$ matches $\textit{rm}(b)$, if $a = b$. To introduce $\textit{check-PQ}$, let us introduce several predicates. Given sequential execution $l$ and priority $p$:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\textit{rm}(\textit{empty}) \notin l$ is satisfied when $l$ does not contain $\textit{rm}(\textit{empty})$.

\item[-] Let $\textit{priorities}(l)$ and $\textit{unmatched-priorities}(l)$ be the set of priorities of putted items and items of unmatched put in $l$, respectively. $p \prec \textit{priorities}(l)$ (resp., $p \preceq \textit{priorities}(l)$), if $p \prec p'$ (resp., $p \preceq p'$)for some $p' \in \textit{priorities}(l)$. Similarly we can define $p \preceq \textit{unmatched-priorities}(l)$.

\item[-] $\textit{matched}_{\prec}(l,p)$ is satisfied, if for each item of $l$ with priorities smaller than $p$, it has matched $\textit{put}$ and $\textit{rm}$. Similarly, we can define $\textit{matched}(l)$, where we consider all items in $l$ instead of items with certain priorities.
\end{itemize}

Let us introduce some notations: given sequential executions $u,v,w$ and priority $p$,

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\textit{PQ}_1(u,v,w,p) \equiv
(\textit{rm}(\textit{empty}) \notin u \cdot v \cdot w) \wedge
(p \not\prec \textit{priorities}(u \cdot v \cdot w)) \wedge
(p \not\preceq \textit{unmatched-priorities}(u \cdot v \cdot w)) \wedge
(\textit{matched}_{\prec}(u \cdot v,p) ) \wedge
(p \notin \textit{priorities}(v \cdot w))$

\item[-] $\textit{PQ}_2(u,v,p) \equiv
(\textit{rm}(\textit{empty}) \notin u \cdot v) \wedge
(p \not\prec \textit{priorities}(u \cdot v \cdot w)) \wedge
(p \notin \textit{priorities}(v \cdot w))$

\item[-] $\textit{PQ}_3(u,v) \equiv
\textit{matched}(u \cdot v)$
\end{itemize}


Let us defined set $\textit{MS}(R)$ ($R \in \textit{PQ}_1,\textit{PQ}_2,\textit{PQ}_3$), which is the set of data-differentiated sequential executions that respect $R$.

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $e \in \textit{MS}(\textit{PQ}_1)$, if $e = u \cdot \textit{put}(x,p) \cdot v \cdot \textit{rm}(x) \cdot w$ and $\textit{PQ}_1(u,v,w,p)$ holds for some item $x$ and a maximal priority $p$,

\item[-] $e \in \textit{MS}(\textit{PQ}_2)$, if $e = u \cdot \textit{put}(x,p) \cdot v$ and $\textit{PQ}_2(u,v,p)$ holds for some item $x$ and a maximal priority $p$,

\item[-] $e \in \textit{MS}(\textit{PQ}_3)$, if $e = u \cdot \textit{rm}(\textit{empty}) \cdot v$ and $\textit{PQ}_3(u,v)$ holds.
\end{itemize}

We call such $x$ and $\textit{rm}(\textit{empty})$ (if exists) the witness of $e$. Note that sequences in $\textit{MS}(R)$ does not guaranteed to be a priority queue execution. Let us introduce the notion $\textit{last}(e)$, which is a set and used as the branch condition of $\textit{check-PQ}$. Here $e$ is a data-differentiated sequential execution.

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $e$ contains $\textit{rm}(\textit{empty})$, then $\textit{last}(e) = \{ \textit{PQ}_3 \}$.

\item[-] Else, if for a maximal priority $p$ of $e$, $\textit{unmatched-priorities}(e) \neq \emptyset$, then $\textit{PQ}_2 \in \textit{last}(e)$.

\item[-] Else, if for a maximal priority $p$ of $e$, $\textit{unmatched-priorities}(e) = \emptyset$, then $\textit{PQ}_1 \in \textit{last}(e)$.
\end{itemize}

When $\textit{last}(e)$ contains only one element $R$, we write $\textit{last}(w)=R$ for simplicity.

The projection $e \vert{\mathcal{D}}$ of $e$ into $\mathcal{D} \subseteq \mathbb{D}$ is obtained from $e$ by erasing all elements with a data value not in $\mathcal{D}$. We write $e \setminus x$ for the projection $e \vert_{ \mathbb{D} \setminus \{ x \} }$. The projection $e \vert{O}$ of $e$ into $O$ is obtained from $e$ by erasing all call and return actions of non-$O$ operations. We write $e \setminus o$ for the projection $e \vert_{ O_e \setminus \{ o \} }$, where $O_e$ is the set of operations of $e$.

The recursive procedure $\textit{con-check-EPQ}$ is given as follows. Here $P_i(e,o)$ and $P_i(e,x)$ is the predicates of $e \in \textit{MS}(\textit{PQ}_i)$ withe witness $o$ or $x$, respectively.

%\begin{minipage}{.5\textwidth}
\begin{algorithm}[H]
\KwIn {a data-differentiated sequential execution $e$}

\If {$e = \epsilon$}
{\KwRet $\textit{true}$;}

\If {$\textit{last}(e) = \textit{PQ}_3$}
{
    \If {$\exists o=\textit{rm}(\textit{empty})$, $P_3(e,o)$ holds}
    {
        \KwRet $\textit{check-PQ}(e \setminus o)$;
    }
    \KwRet $\textit{false}$;
}

\If {$\textit{PQ}_i \in \textit{last}(e)$ for $i \in \{1,2\}$}
{
    \If {$\exists l$, $P_i(e,x)$ holds}
    {
        \KwRet $\textit{check-PQ}(e \setminus x)$;
    }
    \KwRet $\textit{false}$;
}
\caption{$\textit{check-PQ}$}
\label{Method-check-PQ}
\end{algorithm}
%\end{minipage}
%\hfill

\begin{algorithm}[t]
\KwIn {A data-differentiated sequential execution $e$}
\KwOut{$\mathsf{true}$ iff $e\in \seqPQ$}

\If {$e = \epsilon$}
{\Return $\mathsf{true}$\;}

\If {$\mathsf{HasEmptyRemoves}(e)$}
{
    \If {$\exists\ o=\textit{rm}(\textit{empty})\in e$, $P_3(e,o)$ holds}
    {
        \KwRet $\textit{check-PQ}(e \setminus o)$;
    }
    \KwRet $\textit{false}$;
}

\If {$\textit{PQ}_i \in \textit{last}(e)$ for $i \in \{1,2\}$}
{
    \If {$\exists l$, $P_i(e,x)$ holds}
    {
        \KwRet $\textit{check-PQ}(e \setminus x)$;
    }
    \KwRet $\textit{false}$;
}
\caption{$\textit{check-PQ}$}
\label{Method-check-PQ}
\end{algorithm}



Let us use an example to show how $\textit{check-PQ}$ works. Here we use $w_1 \xrightarrow{R} w_2$ to denote that in $\textit{check-PQ}(w_1)$, we choose the branch of $R$ and recursively call $\textit{check-PQ}(w_2)$.

\begin{example}\label{example:generate extended priority queue executions}
Given priorities $p_1,p_2,p_3$ with orders $p_1 \prec p_2$ and $p_1 \prec p_3$,

\noindent $\textit{put}(c,p_2) \cdot \textit{put}(a,p_1) \cdot \textit{rm}(a) \cdot \textit{rm}(c) \cdot \textit{rm}(\textit{empty}) \cdot \textit{put}(d,p_2) \cdot \textit{put}(e,p_3) \cdot \textit{rm}(e) \cdot \textit{put}(b,p_1)$

$\xrightarrow{\textit{EPQ}_3}$ $\textit{put}(c,p_2) \cdot \textit{put}(a,p_1) \cdot \textit{rm}(a) \cdot \textit{rm}(c) \cdot \textit{put}(d,p_2) \cdot \textit{put}(e,p_3) \cdot \textit{rm}(e) \cdot \textit{put}(b,p_1)$

$\xrightarrow{\textit{EPQ}_1}$ $\textit{put}(c,p_2) \cdot \textit{put}(a,p_1) \cdot \textit{rm}(a) \cdot \textit{rm}(c) \cdot \textit{put}(d,p_2) \cdot \textit{put}(b,p_1)$

$\xrightarrow{\textit{EPQ}_2}$ $\textit{put}(c,p_2) \cdot \textit{put}(a,p_1) \cdot \textit{rm}(a) \cdot \textit{rm}(c) \cdot \textit{put}(b,p_1)$

$\xrightarrow{\textit{EPQ}_1}$ $\textit{put}(a,p_1) \cdot \textit{rm}(a) \cdot \textit{put}(b,p_1)$

$\xrightarrow{\textit{EPQ}_2}$ $\textit{put}(a,p_1) \cdot \textit{rm}(a)$

$\xrightarrow{\textit{EPQ}_1}$ $\epsilon$
\end{example}


Let $\textit{PQ}$ be set of sequences obtained by renaming some data-differentiated sequential execution that is accepted by $\textit{check-PQ}$. To persuade readers that $\textit{PQ}$ is indeed the set of behaviors of priority queue, in Appendix \ref{sec:appendix in section inductive rules of extended priority queue}, we give a semantical version definition $\textit{PQ}_s$ of priority queue, and shows that $\textit{PQ} = \textit{PQ}_s$. To model the possible behaviors of priority queue, we model it as an labelled transition system (shortened as LTS) $\textit{LTS}_e$. Each state of $\textit{LTS}_e$ is a function from $\mathbb{P}$ into sequences over $\mathbb{D}$, and represents a snapshot of contents of priority queue. $\textit{PQ}_s$ is the set of traces of $\textit{LTS}_e$. The definition of $\textit{PQ}_s$ and the proof of the following lemma can be found in Appendix \ref{sec:appendix in section inductive rules of extended priority queue}.

\begin{restatable}{lemma}{EPQRulesAndSemantics}
\label{lemma:EPQ rules and semantics}
$\textit{PQ} = \textit{PQ}_s$.
\end{restatable}

By Example \ref{example:generate extended priority queue executions} we can see how to generate a sequence $e \in \textit{EP}$ from $\epsilon$ as follows:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] First we add non-$\textit{rm}(\textit{empty})$ elements with a loop: Let $P$ be the set of priorities of items in $e$. In the first round of the loop, we choose a minimal priorities $p \in P$, we add items by using $\textit{PQ}_1$ and $\textit{PQ}_2$, let $P = P \setminus \{p\}$, and begins the next round of loop.

\item[-] Then, we add $\textit{rm}(\textit{empty})$ by using $\textit{PQ}_3$.
\end{itemize}
