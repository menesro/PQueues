\section{Proof in Section \ref{sec:data-independence of priority queue}}
\label{sec:appendix in section data-independence of PQ}


\DataDifferentiatedisEnoughforPQ*

\begin {proof}

To prove the $\textit{only if}$ direction, given a data-differentiated execution $e \in \mathcal{I}_{\neq}$. By assumption, it is linearizable with respect to a sequential execution $l \in S$, and the bijection between the operations of $e$ and the method events of $l$, ensures that $l$ is differentiated and belongs to $S_{\neq}$.

To prove the $\textit{if}$ direction, given an execution $e \in \mathcal{I}$. By data independence of $\mathcal{I}$, we know that there exists $e' \in \mathcal{I}_{\neq}$ and a renaming function $r$, such that $r(e') = e$. By assumption, $e'$ is linearizable with respect to a sequential execution $l' \in S_{\neq}$. Let $l=r(l')$. By data independence of $S$ it is easy to see that $l \in S$, and it is easy to see that $e \sqsubseteq l$  using the same bijection used for $e' \sqsubseteq l'$. \qed
\end {proof}





\section{Proofs in Section \ref{sec:step-by-step linearizability of priority queues}}
\label{sec:appendix in section step-by-step linearizability of priority queues}


\subsection{Proof of Lemma \ref{lemma:PQ is closed under projection}}

\PQisClosedUnderProjection*

\begin {proof}

This is obvious, since for each conditions in the $\textit{Guard}$ part of the rules of priority queue, if a sequence of sequential executions satisfy it, then its sub-sequence also satisfy it. For example, if $\textit{rm}(\textit{empty}) \notin l = u \cdot v \cdot w$ and let $D_l$ be the set of items of $l$, then for each subset $D' \subseteq D_l$, it is obvious that $\textit{rm}(\textit{empty}) \notin l \vert_{ D' }$. Similar cases hold for $\textit{pri} \geq \textit{maxPri}(l)$, $\textit{pri} > \textit{maxUPri}(l)$, $\textit{matched}(l)$, $\textit{putInSeq}(l,l_1,\textit{pri})$ (let $l_1$ be sub-sequence of $l$). This completes the proof of this lemma. \qed
\end {proof}


\subsection{Proof of Lemma \ref{lemma:PQ as multi in MRpri for sequence}}

\PQasMultiInMRpriforSequence*

\begin {proof}

The \textit{only if} direction is a direct consequence of Lemma \ref{lemma:PQ is closed under projection}, since it is easy to see that each sequence in $\textit{PQueue}$ also belongs to $\textit{MS}(R)$.

To prove the $\textit{if}$ direction. The $\textit{if}$ direction holds trivially if $e = \epsilon$. When $e \neq \epsilon$, we generate sequence $e_1$ from $e$ as follows:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $\textit{last}(e) = \textit{PQ}_3$: $e_1$ is generated from $e$ by erasing one $\textit{rm}(\textit{empty})$.

\item[-] Else, if $\textit{last}(e) = \textit{PQ}_2^{=}$, and the maximal priority of $e$ is unmatched $\textit{put}$ with items in $S$ and matched $\textit{put}$: $e_1$ is generated from $e$ by erasing one unmatched $\textit{put}$ which use the item last putted in $S$.

\item[-] Else, if $\textit{last}(e) = \textit{PQ}_2^{>}$, and the maximal priority in $e$ is unmatched $\textit{put}$ with items in $S$: $e_1$ is generated from $e$ by erasing one unmatched $\textit{put}$ which use the item last putted in $S$.

\item[-] Else, if $\textit{last}(e) = \textit{PQ}_1^{=}$, and the maximal priority in $e$ is of more than one pair of matched $\textit{put}$ with items in $S$: $e_1$ is generated from $e$ by erasing matched $\textit{put}$ and $\textit{rm}$ of the item which is last putted in $S$.

\item[-] Else, if $\textit{last}(e) = \textit{PQ}_1^{>}$: $e_1$ is generated from $e$ by erasing a pair of matched $\textit{put}$ and $\textit{rm}$ with maximal priority in $e$.
\end{itemize}

Similarly, we obtain $e_2$ from $e_1$, obtain $e_3$ from $e_2$, $\ldots$, until we obtain some $e_m = \epsilon$. Let $e_0=e$. It is obvious that $e_m \in \textit{PQueue}$. For $e_{\textit{m-1}}$, since

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $e_m \in \textit{PQueue}$,

\item[-] By assumption, we know that $e_{\textit{m-1}} \in \textit{MS}(R_{\textit{m-1}})$, where $R_{\textit{m-1}} = \textit{last}(R_{\textit{m-1}})$. This implies that the guard of $R_{\textit{m-1}}$ is satisfied.
\end{itemize}

Therefore, we know that $e_{\textit{m-1}} \in \textit{PQueue}$. Similarly, we can prove that $e_{\textit{m-2}},\ldots,e_0 = e \in \textit{PQueue}$. \qed
\end {proof}



\subsection{Proof of Lemma \ref{lemma:PQueue is step-by-step linearizability}}


The prove that $\textit{PQueue}$ is step-by-step linearizability, we investigate each rules individually.

Given a data-differentiated execution and its history, we can abuse notation and mix labels and method events with operations themselves, since items are unique in a data-differentiated execution. For instance, we will reference an operation labeled by $\textit{put}(p,a)$ as $\textit{put}(p,a)$.


Given an operation $o$ with call action $\textit{cal}_o (\textit{put},a,p)$ and return actions $\textit{ret}_o (\textit{put})$, its method event is $\textit{put}(a,p)$. Given an operation $o$ with call action $\textit{cal}_o (\textit{rm})$ and return actions $\textit{ret}_o (\textit{rm},a)$, its method event is $\textit{rm}(a)$.

Given a data-differentiated execution $e$ and its history $h$, we can obtain a sequence $h'$ from $h$ by adding $\textit{put}(a,p)$ (resp., $\textit{rm}(a)$, $\textit{rm}(\textit{empty})$) between each pair of $\textit{cal}(\textit{put},a,p)$ and $\textit{ret}(\textit{put},a)$ (resp., $\textit{cal}(\textit{rm},a)$ and $\textit{ret}(\textit{rm},a)$, $\textit{cal}(\textit{rm},\textit{empty})$ and $\textit{ret}(\textit{rm},\textit{empty})$). The projection of $h'$ into method events is called linearization of $e$ and $h$, and each method event we add in $h'$ can be considered as a linearization point of the corresponding method event.

\begin{restatable}{lemma}{PQ1LarisStepByStepLinearizability}
\label{lemma:PQ1Lar is step-by-step linearizability}
If concurrent execution $e$ is linearizable w.r.t. $\textit{MS}(\textit{PQ}_1^{>})$ with witness $x$, then $e \setminus x \sqsubseteq \textit{PQueue} \Rightarrow e \sqsubseteq \textit{PQueue}$.
\end{restatable}

\begin {proof}

Let $h$ be the data-differentiated history of $e$, and $l$ be an sequential execution such that $h \sqsubseteq l$ and $l$ matches $\textit{PQ}_1^{>}$ with witness $x$. Let $h'=h \setminus x$ and assume that $h' \sqsubseteq l' \in \textit{PQueue}$.

According to $\textit{MS}(\textit{PQ}_1^{>})$, there exist sequences $u$, $v$, and $w$, such that $l=u \cdot \textit{put}(x,\textit{pri}_x) \cdot v \cdot \textit{rm}(x) \cdot w$, where the $\textit{put}$ and $\textit{rm}$ in $u \cdot v$ are matched, and $\textit{pri}_x$ is larger than priority of any method event in $u \cdot v \cdot w$. Let $D_L$ be the set of items in $u \cdot v$, let $D_R$ be the set of items in $w$. Since $u \cdot v$ contain only matched $\textit{put}$ and $\textit{rm}$, we can see that $D_L \cap D_R = \emptyset$. Let $l'_L = l' \vert_{D_L}$ and $l'_R = l' \vert_{D_R}$. Let $S_1$ be the set of operations of $h$ that happen before $\textit{put}(x,\textit{pri}_x)$, let $l'_{L1}$ be the shortest prefix of $l'_L$ that contains all method events of operations in $S_1$, and let $l'_{L2}$ be the sequence such that $l'_L = l'_{L1} \cdot l'_{L2}$. It is obvious that if $\textit{put}(x,\textit{pri}_x)$ happens before an operation $o$ in $h$, then $o$ is in $l'_{L2}$. Let sequence $l'' = l'_{L1} \cdot \textit{put}(x,\textit{pri}_x) \cdot l'_{L2} \cdot \textit{rm}(x) \cdot L'_R$.

Since priority queue is closed under projection (Lemma \ref{lemma:PQ is closed under projection}) and $u \cdot v$ contain matched $\textit{put}$ and $\textit{rm}$, we know that $l'_{L1} \cdot l'_{L2} \in \textit{PQueue}$ and $l'_R \in \textit{PQueue}$. Since $\textit{pri}_x$ is larger than any priority in $h$, it is easy to see that $l'_{L1} \cdot \textit{put}(x,\textit{pri}_x) \cdot l'_{L2} \cdot \textit{rm}(x) \in \textit{PQueue}$. Since the priority queue is empty after executing $l'_{L1} \cdot \textit{put}(x,\textit{pri}_x) \cdot l'_{L2} \cdot \textit{rm}(x) \in \textit{PQueue}$, we know that $l'' = l'_{L1} \cdot \textit{put}(x,\textit{pri}_x) \cdot l'_{L2} \cdot \textit{rm}(x) \cdot L'_R \in \textit{PQueue}$.

It remains to prove that $h \sqsubseteq l''$. To prove this, we define a graph $G$ whose nodes are the operations of $h$ and there is an edge from operation $o_1$ to $o_2$, if one of the following case holds

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $o_1$ happens-before $o_2$ in h,

\item[-] the method event corresponding to $o_1$ in $l''$ is before the one corresponding to $o_2$.
\end{itemize}

Assume there is a cycle in $G$. According the the property of interval order and the fact that the order of $l''$ is total, we know that there must exists $o_1$ and $o_2$, such that $o_1$ happens-before $o_2$ in $h$, but the corresponding method events are in the opposite order in $l''$. Then, we can see

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $o_1,o_2 \in l'_{L1}$, or $o_2 \in l'_{L1} \wedge o_1 \in l'_{L2}$, or $o_1,o_2 \in l'_{L2}$, or $o_1,o_2 \in L'_R$, then $l'$ contradicts with happen before relation of $h$.

\item[-] If $o_1 = \textit{put}(x,\textit{pri}_x) \wedge o_2 \in l'_{L1}$, then since $\textit{put}(x,\textit{pri}_x)$ happens before $o_2$, we know that $o_2 \in l'_{L2}$, which contradicts that $o_2 \in l'_{L1}$.

\item[-] If $o_1 = \textit{rm}(x) \wedge (o_2 \in  l'_{L1} \vee o_2 = \textit{put}(x,\textit{pri}_x) \vee o_2 \in l'_{L2})$, or $o_1 \in L'_R \wedge ( o_2 \in l'_{L1} \vee o_2 = \textit{put}(x,\textit{pri}_x) \vee o_2 \in l'_{L2} \vee o_2 = \textit{rm}(x) )$, then $l$ contradicts with happen before relation of $h$.

\item[-] If $o_1 \in l'_{L2} \wedge o_2 = \textit{put}(x,\textit{pri}_x)$, then since $o_1$ happens before $\textit{put}(x,\textit{pri}_x)$, we know that $o_1 \in S_1$ and then $o_1 \in l'_{L1}$, which contradicts that $o_1 \in l'_{L2}$.
\end{itemize}

Therefore, we know that $G$ is acyclic, and then we know that $h \sqsubseteq \textit{PQueue}$. \qed
\end {proof}


\begin{restatable}{lemma}{PQ1EqualisStepByStepLinearizability}
\label{lemma:PQ1Equal is step-by-step linearizability}
If concurrent execution $e$ is linearizable w.r.t. $\textit{MS}(\textit{PQ}_1^{=})$ with witness $x$, then $e \setminus x \sqsubseteq \textit{PQueue} \Rightarrow e \sqsubseteq \textit{PQueue}$.
\end{restatable}

\begin {proof}

Let $h$ be the data-differentiated history of $e$, and $l$ be an sequential execution such that $h \sqsubseteq l$ and $l$ matches $\textit{PQ}_1^{=}$ with witness $x$. Let $h'=h \setminus x$ and assume that $h' \sqsubseteq l' \in \textit{PQueue}$.

Since $h' \sqsubseteq l'$, there exists a sequence $e_{l'}$ generated from $e$ by adding method events of $e \setminus x$, and $e_{l'}$ satisfies that (1) the projection of $e_{l'}$ into call and return action is $e$, (2) the projection of $e_{l'}$ into method events is $l'$, and (3) for each matched pair of call action $c$ and return action $r$ of $e$ (if their item is not $x$), there exists a method event $o$, such that $c$ before $o$ in $h'_{l'}$, $o$ before $r$ in $h'_{l'}$, and $o$ is the method event of $c$ and $r$. Intuitively, $e_{l'}$ is obtained from $h$ by adding linearization points according to $l'$.

According to $\textit{PQ}_1^{=}$, there exist sequences $u$, $v$, and $w$, such that $l=u \cdot \textit{put}(x,\textit{pri}_x) \cdot v \cdot \textit{rm}(x) \cdot w$, where (1) the $\textit{put}$ and $\textit{rm}$ in $u \cdot v$ are matched, (2) $\textit{pri}_x$ is the maximal priority in $u \cdot v \cdot w$, (3) there exists matched $\textit{put}$ and $\textit{rm}$ in $u \cdot v \cdot w$ that has priority $\textit{pri}_x$, (4) $\textit{pri}_x$ is larger than priorities of any unmatched put in $u \cdot v \cdot w$, and (5) all $\textit{put}$ with priority $\textit{pri}_x$ is in $u$. Let $D_L$ be the set of items in $u \cdot v$, let $D_R$ be the set of items in $w$. Since $u \cdot v$ contain only matched $\textit{put}$ and $\textit{rm}$, we can see that $D_L \cap D_R = \emptyset$. Let $l'_L = l' \vert_{D_L}$ and $l'_R = l' \vert_{D_R}$.

Let $l'_{\textit{L0}}$ be the shortest prefix of $l'$, such that the linearization point of every method event in  $l'_{\textit{L0}}$ is before the return action of $\textit{put}(x,\textit{pri}_x)$ in $e_{l'}$. Let $E_{px}$ be the set of $\textit{put}$ with priority $\textit{pri}_x$ in $e \setminus x$. Let $l'_{\textit{L1}} = l'_{\textit{L0}} \cdot l_t$, where $l_t$ is the projection of $l'$ into method events of $E_{px}$ that are not in $l'_{\textit{L0}}$. Let $l'_{\textit{L2}}$ be the projection of $l'_L$ into method events of $l'_L$ that are not in $l'_{\textit{L1}}$. Let sequence $l'' = l'_{L1} \cdot \textit{put}(x,\textit{pri}_x) \cdot l'_{L2} \cdot \textit{rm}(x) \cdot L'_R$.

As in Lemma \ref{lemma:PQ1Lar is step-by-step linearizability}, we know that $l'_L \in \textit{PQueue}$ and $l'_R \in \textit{PQueue}$. It is obvious that $l'_{\textit{L0}} \in \textit{PQueue}$, and then $l'_{\textit{L1}} = l'_{\textit{L0}} \cdot l_t \in \textit{PQueue}$. Since there is no $\textit{rm}(\textit{Empty})$ in $h$ and $\textit{pri}_x$ is the maximal priority of $h$, $l'_{L1} \cdot l'_{L2} \in \textit{PQueue}$. Since all $\textit{put}$ operations with priority $\textit{pri}_x$ is in $l'_{L1}$, we know that $l'_{L1} \cdot \textit{put}(x,\textit{pri}_x) \cdot l'_{L2} \cdot \textit{rm}(x) \in \textit{PQueue}$. Since the priority queue is empty after executing $l'_{L1} \cdot \textit{put}(x,\textit{pri}_x) \cdot l'_{L2} \cdot \textit{rm}(x) \in \textit{PQueue}$, we know that $l'' \in \textit{PQueue}$.

To prove $h \sqsubseteq l''$, we define graph $G$ as in Lemma \ref{lemma:PQ1Lar is step-by-step linearizability}. Assume that there is a cycle in $G$, then there must exists $o_1$ and $o_2$, such that $o_1$ happens-before $o_2$ in $h$, but the corresponding method events are in the opposite order in $l''$. Then, we can see

\begin{itemize}
\setlength{\itemsep}{0.5pt}

\item[-] $o_1 \in L'_R \wedge (o_2 \in l'_{L1} \vee o_2 = \textit{put}(x,\textit{pri}_x) \vee o_2 \in l'_{L2} \vee o_2 = \textit{rm}(x))$, or $o_1 = \textit{rm}(x) \wedge (o_2 \in l'_{L1} \vee o_2 = \textit{put}(x,\textit{pri}_x) \vee o_2 \in l'_{L2})$: Then $l$ contradicts with happen before relation of $h$.

\item[-] $o_1, o_2 \in l'_R$ or $o_1, o_2 \in l'_{L2}$: Then $l'$ contradicts with happen before relation of $h$.

\item[-] $o_1, o_2 \in l'_{L1}$: If $(o_1, o_2 \in l'_{L0}) \vee (o_1,o_2 \in l_t)$, then $l'$ contradicts with happen before relation of $h$.

    Else, it is the case that $o_1 \in l_t \wedge o_2 \in l'_{L0}$. We can see that $o_1$ interleaves with $\textit{put}(x,\textit{pri}_x)$ and the linearization point of $o_1$ is after the return action of $\textit{put}(x,\textit{pri}_x)$ in $e_{l'}$. Since $o_1 <_{\textit{hb}} o_2$, it is easy to see that $\textit{put}(x,\textit{pri}_x) <_{\textit{hb}} o_2$, then $o_2 \notin l'_{L0}$, which contradicts that $o_2 \in l'_{L0}$.

\item[-] $o_1 = \textit{put}(x,\textit{pri}_x) \wedge o_2 \in l'_{L1}$: Since $o_1 <_{\textit{hb}} o_2$, it is obvious that $o_2 \notin l'_{L1}$, contradicts that $o_2 \in l'_{L1}$.

\item[-] $o_1 \in l'_{L2} \wedge o_2 \in l'_{L1}$: If $o_2 \in l'_{L0}$, then $l'$ contradicts with happen before relation of $h$.

    Else, it is the case that $o_2 \in l_t$. Since $o_2$ interleaves with $\textit{put}(x,\textit{pri}_x)$ and $o_1 <_{\textit{hb}} o_2$, the return action of $o_1$ is before the return action of $\textit{put}(x,\textit{pri}_x)$ in $e$. Then it is easy to see that $o_1 \in l'_{L0}$, contradicts that $o_1 \in l'_{L2}$.

\item[-] $o_1 \in l'_{L2} \wedge o_2 = \textit{put}(x,\textit{pri}_x)$: Then $o_1 \in l'_{L0}$, contradicts that $o_1 \in l'_{L2}$.
\end{itemize}

Therefore, we know that $G$ is acyclic, and then we know that $h \sqsubseteq \textit{PQueue}$. \qed
\end {proof}



\begin{restatable}{lemma}{PQ2LarisStepByStepLinearizability}
\label{lemma:PQ2Lar is step-by-step linearizability}
If concurrent execution $e$ is linearizable w.r.t. $\textit{MS}(\textit{PQ}_2^{>})$ with witness $x$, then $e \setminus x \sqsubseteq \textit{PQueue} \Rightarrow e \sqsubseteq \textit{PQueue}$.
\end{restatable}

\begin {proof}

Let $h$ be the data-differentiated history of $e$, and $l$ be an sequential execution such that $h \sqsubseteq l$ and $l$ matches $\textit{PQ}_1^{>}$ with witness $x$. Let $h'=h \setminus x$ and assume that $h' \sqsubseteq l' \in \textit{PQueue}$.

According to $\textit{PQ}_2^{>}$, there exist sequences $u$ and $v$, such that $l=u \cdot \textit{put}(x,\textit{pri}_x) \cdot v$, where $\textit{pri}_x$ is the maximal priority in $u \cdot v$, $\textit{pri}_x$ is larger than priority of any matched $\textit{put}$ in $u \cdot v$ (may equal priority of some unmatched $\textit{put}$ operations in $u \cdot v$), and all other $\textit{put}$ with priority $\textit{pri}_x$ is in $u$. Let $S_1$ be the set of operations of $e$ that happen before $\textit{put}(x,\textit{pri}_x)$, let $l'_1$ be the shortest prefix of $l'$ that contains all method events of operations of $S_1$, and let $l'_2$ be the sequence such that $l' = l'_1 \cdot l'_2$. Let sequence $l'' = l'_1 \cdot \textit{put}(x,\textit{pri}_x) \cdot l'_2$.

Since $\textit{pri}_x$ is larger than priority of any matched $\textit{put}$ operations in $u \cdot v$, it is easy to see that $l'' \in \textit{PQueue}$. It remains to prove that $h \sqsubseteq l''$. To prove $h \sqsubseteq l''$, we define graph $G$ as in Lemma \ref{lemma:PQ1Lar is step-by-step linearizability}. Assume that there is a cycle in $G$, then there must exists $o_1$ and $o_2$, such that $o_1$ happens-before $o_2$ in $h$, but the corresponding method events are in the opposite order in $l''$. Then, we can see

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $o_1,o_2 \in l'_1$, or $o_1,o_2 \in l'_2$, or $o_1 \in l'_2 \wedge o_2 \in l'_1$: Then $l'$ contradicts with happen before relation of $h$.

\item[-] $o_1 \in l'_2 \wedge o_2 = \textit{put}(x,\textit{pri}_x)$: $o_1 \in S_1$, and then $o_1 \in l'_1$, which contradicts that $o_1 \in l'_2$.

\item[-] $o_1 = \textit{put}(x,\textit{pri}_x) \wedge o_2 \in l'_1$: We can see that in $l'$, $o_2$ must after every operation in $S_1$, and then $o_2 \notin l'_1$, contradicts that $o_2 \in l'_1$.
\end{itemize}

Therefore, we know that $G$ is acyclic, and then we know that $h \sqsubseteq \textit{PQueue}$. \qed
\end {proof}


\begin{restatable}{lemma}{PQ2EqualisStepByStepLinearizability}
\label{lemma:PQ2Equal is step-by-step linearizability}
If concurrent execution $e$ is linearizable w.r.t. $\textit{MS}(\textit{PQ}_2^{=})$ with witness $x$, then $e \setminus x \sqsubseteq \textit{PQueue} \Rightarrow e \sqsubseteq \textit{PQueue}$.
\end{restatable}

\begin {proof}
Let $h$ be the data-differentiated history of $e$, and $l$ be an sequential execution such that $h \sqsubseteq l$ and $l$ matches $\textit{PQ}_1^{>}$ with witness $x$. Let $h'=h \setminus x$ and assume that $h' \sqsubseteq l' \in \textit{PQueue}$.

According to $\textit{PQ}_2^{=}$, there exist sequences $u$ and $v$, such that (1) $l=u \cdot \textit{put}(x,\textit{pri}_x) \cdot v$, (2) $\textit{pri}_x$ is the maximal priority in $u \cdot v$, (3) $\textit{pri}_x$ equals the maximal priority of matched $\textit{put}$ in $u \cdot v$, (4) all matched $\textit{put}$ with priority $\textit{pri}_x$ is in $u$ and (5) all the other unmatched $\textit{put}$ operations with priority $\textit{pri}_x$ is in $u$.

Similarly as in Lemma \ref{lemma:PQ1Equal is step-by-step linearizability}, we can obtain a sequence $e_{l'}$ from $e$ by adding linearization points according to $l'$. Let $l'_1$ be the shortest prefix of $l'$, such that the linearization point of every method event in $l'_1$ is before the return action of $\textit{put}(x,\textit{pri}_x)$ in $e_{l'}$. Let $E_{px}$ be the set of $\textit{put}$ with priority $\textit{pri}_x$ in $e \setminus x$. Let $l'_2$ be the projection of $l'$ into method events of $E_{px}$ that are not in $l'_1$. Let $l_x' = l'_1 \cdot l'_2 \cdot \textit{put}(x,\textit{pri}_x) \cdot l'_3$, where $l'_3$ is the projection of $l'$ into method events that are not in $l'_1 \cdot l'_2$.

Let $l_x$ be generated from $l'_x$ by erasing $\textit{put}(x,\textit{pri}_x)$. Since (1) $l_x$ can be obtained from $l'$ by making some $\textit{put}$ happen earlier, (2) for each $\textit{rm}(a)$ in $l'$, its corresponding $\textit{put}(a,\_)$ must before it in $l'$, and (3) there are no $\textit{rm}(\textit{empty})$ in $l'$, we can see that $l_x \in \textit{PQueue}$. Since $\textit{pri}_x$ is the maximal priority in $l$ and there are no $\textit{rm}(\textit{empty})$ in $l$, we can see that $l'_x \in \textit{PQueue}$.

Let us prove that $h \sqsubseteq l'_x$ by contradiction. Assume that there exists operations $o_1,o_2$, such that $o_1$ happens before $o_2$ in $h$, and $o_2$ is before $o_1$ in $l'_x$. Then, we can see


\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $o_1, o_2 \in l'_1$, or $o_1, o_2 \in l'_2$, or $o_1, o_2 \in l'_3$: Then $l'$ contradicts with happen before relation of $h$.

\item[-] $o_2 \in l'_1 \wedge o_1 \in l'_2$: Then by construction of $l'_1$, it is easy to see that $o_1 \in l'_1$, which contradicts that $o_1 \in l'_2$.

\item[-] $o_2 \in l'_1 \wedge o_1 = \textit{put}(x,\textit{pri}_x)$: Then by construction of $l'_1$, it is easy to see that $o_2 \notin l'_1$, which contradicts that $o_2 \in l'_2$.

\item[-] $o_2 \in l'_1 \wedge o_1 \in l'_3$: Then by construction of $l'_1$, it is easy to see that $o_1 \in l'_1$, which contradicts that $o_1 \in l'_3$.

\item[-] $o_2 \in l'_2 \wedge o_1 = \textit{pt}(x,\textit{pri}_x)$: It is easy to see that each method event in $l'_2$ is a $\textit{put}$ with priority $\textit{pri}$. By $l'$ we know that $\textit{pt}(x,\textit{pri}_x)$ does not happen before any of them.

\item[-] $o_2 \in l'_2 \wedge o_1 \in l'_3$: It is easy to see that each method event in $l'_2$ is a $\textit{put}$ $o$ with priority $\textit{pri}$ and $o$ interleaves with $\textit{put}(x,\textit{pri}_x)$. Since $o_1$ happens before $o_2$, it is obviou that the return action of $o_1$ is before the return action of $\textit{put}(x,\textit{pri}_x)$ in $e$, and then $o_1 \in l'_1$, which contradicts that $o_1 \in l'_3$.

\item[-] $o_2 = \textit{put}(x,\textit{pri}_x) \wedge o_1 \in l'_3$: It is not hard to see that $o_1 \in l'_1$, which contradicts that $o_1 \in l'_3$.
\end{itemize}

Therefore, we know that $G$ is acyclic, and then we know that $h \sqsubseteq l'_x$. \qed
\end {proof}


\begin{restatable}{lemma}{PQ3isStepByStepLinearizability}
\label{lemma:PQ3 is step-by-step linearizability}
If concurrent execution $e$ is linearizable w.r.t. $\textit{MS}(\textit{PQ}_3)$ and $o$ is a $\textit{rm}(\textit{empty})$ event, then $e \setminus o \sqsubseteq \textit{PQueue} \Rightarrow e \sqsubseteq \textit{PQueue}$.
\end{restatable}

\begin {proof}
Let $h$ be the data-differentiated history of $e$, $l$ be an sequential execution such that $h \sqsubseteq l$, $l$ matches $\textit{PQ}_3$ and $o$ is a $\textit{rm}$ method event in $h$. Let $h'=h \setminus o$ and assume that $h' \sqsubseteq l' \in \textit{PQueue}$.

According to $\textit{PQ}_3$, there exist sequences $u$ and $v$, such that $l=u \cdot \textit{rm}(\textit{empty}) \cdot v$, where the $\textit{put}$ operations and $\textit{rm}$ in $u$ are matched.

Let $E_L$ be the set of method events in $u$ and $E_R$ be the set of method events in $v$. Let $l'_L = l' \vert_{E_L}$ and $l'_R = l' \vert_{E_R}$. Let sequence $l'' = l'_L \cdot o \cdot L'_R$. Since priority queue is closed under projection (Lemma \ref{lemma:PQ is closed under projection}) and $u$ contains matched $\textit{put}$ and $\textit{rm}$, we know that $l'_L \in \textit{PQueue}$ and the the priority queue is empty after executing $l'_L$. Then we know that $l'_L \cdot o \in \textit{PQueue}$. Since $l'_R$ is obtained from $l'$ by discarding pairs of matched $\textit{put}$ and $\textit{rm}$ operations, it is easy to see that $L'_R \in \textit{PQueue}$, and then we know that $l'' = l'_L \cdot o \cdot L'_R \in \textit{PQueue}$.

It remains to prove that $h \sqsubseteq l''$. To prove $h \sqsubseteq l''$, we define graph $G$ as in Lemma \ref{lemma:PQ1Lar is step-by-step linearizability}. Assume that there is a cycle in $G$, then there must exists $o_1$ and $o_2$, such that $o_1$ happens-before $o_2$ in $h$, but the corresponding method events are in the opposite order in $l''$. Then, we can see

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $o_1,o_2 \in l'_L$, or $o_1,o_2 \in l'_R$: Then $l'$ contradicts with happen before relation of $h$.

\item[-] If $o_1=o \wedge o_2 \in l'_L$, or $o_1 \in l'_R \wedge o_2 \in l'_L$, or $o_1 \in l'_R \wedge o_2 = 0$, then $l$ contradicts with happen before relation of $h$.
\end{itemize}

Therefore, we know that $G$ is acyclic, and then we know that $h \sqsubseteq \textit{PQueue}$. \qed
\end {proof}

The following lemma states that $\textit{PQueue}$ is step-by-step linearizability, it is a direct consequence of Lemma \ref{lemma:PQ1Lar is step-by-step linearizability}, Lemma \ref{lemma:PQ1Equal is step-by-step linearizability}, Lemma \ref{lemma:PQ2Lar is step-by-step linearizability}, Lemma \ref{lemma:PQ2Equal is step-by-step linearizability} and Lemma \ref{lemma:PQ3 is step-by-step linearizability}.


\PQueueisStepByStepLinearizability*

\begin {proof}
This is a direct consequence of Lemma \ref{lemma:PQ1Lar is step-by-step linearizability}, Lemma \ref{lemma:PQ1Equal is step-by-step linearizability}, Lemma \ref{lemma:PQ2Lar is step-by-step linearizability}, Lemma \ref{lemma:PQ2Equal is step-by-step linearizability} and Lemma \ref{lemma:PQ3 is step-by-step linearizability}. \qed
\end {proof}


\subsection{Proof of Lemma \ref{lemma:PQ as multi in MRpri for history}}

\PQasMultiInMRpriforHistory*

\begin {proof}

To prove the $\textit{only if}$ direction, assume that $e \sqsubseteq l \in \textit{PQueue}$. Given $e' = e \vert_{D}$, by Lemma \ref{lemma:PQ is closed under projection}, it is obvious that $e' \sqsubseteq l' = l \vert_{D} \in \textit{PQueue}$. Then by Lemma \ref{lemma:PQ as multi in MRpri for sequence} we know that $l' \in \textit{MS}(R)$ where $R = \textit{last}(e')$.

To prove the $\textit{if}$ direction. The $\textit{if}$ direction holds trivially if $e = \epsilon$. When $e \neq \epsilon$, we generate concurrent execution $e_1$ from $e$ as follows: Since $e \in \textit{proj}(e)$ we know that $e \sqsubseteq \textit{MS}(R_e)$, where $R_e = \textit{last}(e)$,

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $R_e = \textit{PQ}_3$: $e_1$ is generated from $e$ by erasing call and return of one $\textit{rm}(\textit{empty})$.

\item[-] Else, if $R_e = \textit{PQ}_2^{=}, \textit{PQ}_2^{>}, \textit{PQ}_1^{=}, \textit{PQ}_1^{>}$, and the witness is $x$: $e_1$ is generated from $e$ by erasing call and return of method event of $x$.
\end{itemize}

Similarly, we obtain $e_2$ from $e_1$, obtain $e_3$ from $e_2$, $\ldots$, until we obtain some $e_m = \epsilon$. Let $e_0=e$. It is obvious that $e_m \sqsubseteq \textit{PQueue}$. For $e_{\textit{m-1}}$, since

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $e_m \sqsubseteq \textit{PQueue}$,

\item[-] If $\textit{last}(e_{\textit{m-1}}) = R_{\textit{m-1}} \in \{ \textit{PQ}_1^{>}, \textit{PQ}_1^{=}, \textit{PQ}_2^{>}, \textit{PQ}_2^{=} \}$ and $e$ matches $R_{\textit{m-1}}$ with witness $x$: We already know that $e_{\textit{m-1}} \sqsubseteq \textit{MS}(R_{\textit{m-1}})$, $e_{\textit{m-1}} \setminus x \sqsubseteq \textit{PQueue}$, and by step-by-step linearizability of $\textit{PQueue}$, we can see that $e_{\textit{m-1}} \sqsubseteq \textit{PQueue}$.


\item[-] If $\textit{last}(e_{\textit{m-1}}) = R_{\textit{m-1}} = \textit{PQ}_3$ and $o$ is a $\textit{rm}(\textit{empty})$ in $e_{\textit{m-1}}$: We already know that $e_{\textit{m-1}} \sqsubseteq \textit{MS}(R_{\textit{m-1}})$, $e_{\textit{m-1}} \setminus o \sqsubseteq \textit{PQueue}$, and by step-by-step linearizability of $\textit{PQueue}$, we can see that $e_{\textit{m-1}} \sqsubseteq \textit{PQueue}$.
\end{itemize}

Therefore, we know that $e_{\textit{m-1}} \in \textit{PQueue}$. Similarly, we can prove that $e_{\textit{m-2}},\ldots,e_0 = e \in \textit{PQueue}$. \qed
\end {proof}


\section{Proofs and Definitions in Section \ref{sec:co-regular of priority queues}}
\label{sec:appendix proof and definition in section co-regular of priority queues}


\subsection{Proofs and Definitions in Subsection \ref{subsec:definition of co-regular}}
\label{sec:appendix proof and definition in section definition of co-regular}

\cite{Bouajjani:2015} states that, given a differentiated queue execution $e$ without $\textit{deq}(\textit{empty})$, $e$ is not linearizable with respect to queue, if one of the following cases holds for some $a,b$: (1) $\textit{deq}(b) <_{hb} \textit{enq}(b)$, (2) there are are no $\textit{enq}(b)$ and least one $\textit{deq}(b)$, (3) there are are one $\textit{enq}(b)$ and more than one $\textit{deq}(b)$, and (4) $\textit{enq}(a) <_{\textit{hb}} \textit{enq}(b)$, and $\textit{deq}(b) <_{\textit{hb}} \textit{deq}(a)$, or $\textit{deq}(a)$ does not exists.

For each such case, we construct a witness automata. We generate witness automata $\mathcal{A}_{\textit{SinPri}}^1$ for the first case, and it is shown in \figurename~\ref{fig:automata for FIFO-1 in appendix}. Here $c_1 = \textit{cal}(\textit{put},a,\textit{anyPri})$, $\textit{ret}(\textit{put},a), \textit{cal}(\textit{rm},a),\textit{ret}(\textit{rm},a),\textit{cal}(\textit{rm},b),\textit{cal}(\textit{rm},\textit{empty}),\textit{ret}(\textit{rm},\textit{empty})$, $c_2 = c_1 + \textit{ret}(\textit{rm},b)$, $c_3 = c_2 + \textit{ret}(\textit{put},b)$.


\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.6 \textwidth]{figures/PIC_AUTO_FIFO_1.pdf}
%\vspace{-10pt}
  \caption{Automaton $\mathcal{A}_{\textit{SinPri}}^1$}
  \label{fig:automata for FIFO-1 in appendix}
\end{figure}


We generate witness automata $\mathcal{A}_{\textit{SinPri}}^2$ for the second case, and it is shown in \figurename~\ref{fig:automata for FIFO-2}. Here $c_1 = \textit{cal}(\textit{put},a,\textit{anyPri}),\textit{ret}(\textit{put},a), \textit{cal}(\textit{rm},a),\textit{ret}(\textit{rm},a),\textit{cal}(\textit{rm},\textit{empty}),\textit{ret}(\textit{rm},\textit{empty})$, $c_2 = c_1 + \textit{cal}(\textit{rm},b) + \textit{ret}(\textit{rm},b)$.


\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.3 \textwidth]{figures/PIC_AUTO_FIFO_2.pdf}
%\vspace{-10pt}
  \caption{Automaton $\mathcal{A}_{\textit{SinPri}}^2$}
  \label{fig:automata for FIFO-2}
\end{figure}

We generate witness automata $\mathcal{A}_{\textit{SinPri}}^3$ for the third case, and it is shown in \figurename~\ref{fig:automata for FIFO-3}. Here $c_1 = \textit{cal}(\textit{put},a,\textit{anyPri}),\textit{ret}(\textit{put},a), \textit{cal}(\textit{rm},a),\textit{ret}(\textit{rm},a),\textit{cal}(\textit{rm},\textit{empty}),\textit{ret}(\textit{rm},\textit{empty})$, $c_2 = c_1 + \textit{ret}(\textit{put},b)$, $c_3 = c_2 + \textit{ret}(\textit{rm},b)$, $c_4 = c_3 + \textit{cal}(\textit{rm},b)$, $c_5 = c_1 + \textit{ret}(\textit{rm},b)$, $c_6 = c_5 + \textit{cal}(\textit{rm},b)$.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7 \textwidth]{figures/PIC_AUTO_FIFO_3.pdf}
%\vspace{-10pt}
  \caption{Automaton $\mathcal{A}_{\textit{SinPri}}^3$}
  \label{fig:automata for FIFO-3}
\end{figure}

We generate witness automata $\mathcal{A}_{\textit{SinPri}}^4$ for the forth case, and it is shown in \figurename~\ref{fig:automata for FIFO-4}. Here $c_1 = c + \textit{cal}(\textit{rm},b)$, and $c_2 = c + \textit{ret}(\textit{put},b) + \textit{cal}(\textit{rm},a) + \textit{ret}(\textit{rm},a)$, where $c = \textit{cal}(\textit{put},d,\textit{anyPri}),\textit{ret}(\textit{put},d), \textit{cal}(\textit{rm},d),\textit{ret}(\textit{rm},d),\textit{cal}(\textit{rm},\textit{empty}),\textit{ret}(\textit{rm},\textit{empty})$.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.9 \textwidth]{figures/PIC_AUTO_FIFO_4.pdf}
%\vspace{-10pt}
  \caption{Automaton $\mathcal{A}_{\textit{SinPri}}^4$}
  \label{fig:automata for FIFO-4}
\end{figure}

Let $\textit{Auts}_{\textit{sinPri}} = \{ \mathcal{A}_{\textit{SinPri}}^1, \mathcal{A}_{\textit{SinPri}}^2, \mathcal{A}_{\textit{SinPri}}^3, \mathcal{A}_{\textit{SinPri}}^4 \}$. Let us prove Lemma \ref{lemma:automata for priority queue with single priority}.

\AutoForPQwithSignlePri*

\begin {proof}

\cite{Bouajjani:2015} states that, given a differentiated queue execution $e$ without $\textit{deq}(\textit{empty})$, $e$ is not linearizable with respect to queue, if one of the following cases holds for some $v_a,v_b$: (1) $\textit{deq}(v_b) <_{hb} \textit{enq}(v_b)$, (2) there are are no $\textit{enq}(v_b)$ and least one $\textit{deq}(v_b)$, (3) there are are one $\textit{enq}(v_b)$ and more than one $\textit{deq}(v_b)$, and (4) $\textit{enq}(v_a) <_{\textit{hb}} \textit{enq}(v_b)$, and $\textit{deq}(v_b) <_{\textit{hb}} \textit{deq}(v_a)$, or $\textit{deq}(v_a)$ does not exists.

Let us prove the $\textit{only if}$ direction. Assume that there exists execution $e_0 \in \mathcal{I}$ and $e_0$ is accepted by an automaton in $\textit{Auts}_{\textit{sinPri}}$. By data-independence, we can see that there exists a data-differentiated $e \in \mathcal{I}$ and renaming function, such that $e_0=r(e)$. Let $e'$ be obtained from $e$ by erasing $\textit{rm}(\textit{empty})$ and it is obvious that $e' \in \textit{proj}(e)$. It is easy to see that $e'$ satisfies one of above conditions, and then $e'$ is not linearizable w.r.t queue.

Let us prove the $\textit{if}$ direction. Assume that exists $e \in \mathcal{I}_{\neq}$, $e' \in \textit{proj}(e)$, such that $e'$ is single-priority  without $\textit{rm}(\textit{empty})$, and $\textit{transToQueue}(e')$ does not linearizable to queue. Then we construct a renaming function $r$ as follows:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If this is because case $1$, case $2$ or case $3$: $r$ maps $v_b$ into $b$ and maps all other values into $a$.

\item[-] If this is because case $4$: $r$ maps $v_a$ and $v_b$ into $a$ and $b$, respectively, and maps all other values into $d$.
\end{itemize}

Then it is not hard to see that $r(e) \in \mathcal{I}$ and it is accepted by some automaton in $\textit{Auts}_{\textit{sinPri}}$. This completes the proof of this lemma. \qed
\end {proof}




\subsection{Proofs and Definitions in Subsection \ref{subsec:co-regular of PQ1Lar}}
\label{sec:appendix proof and definition in section co-regular of PQ1Lar}

We can see that $\textit{UVSet}_i(e,x) \cap \textit{UVSet}_j(e,x) = \emptyset$ for any $i \neq j$.

The following lemma states that $\textit{UVSet}(e,x)$ contains only matched $\textit{put}$ and $\textit{rm}$.

\begin{restatable}{lemma}{UVSetHasMatchedPutandRm}
\label{lemma:UVSet has matched put and rm}
Given a data-differentiated execution $e$ with $\textit{last}(e) = \textit{PQ}_1^{>}$. Let $\textit{put}(x,\textit{pri}_x)$ and $\textit{rm}(x)$ be method events of $e$ with maximal priority. Let $G$ be the graph representing the left-right constraint of $\textit{put}(x,\textit{pri}_x)$ and $\textit{rm}(x)$. Assume that $G$ has no cycle going through $x$. Then, $\textit{UVSet}(e,x)$ contains only matched $\textit{put}$ and $\textit{rm}$.
\end{restatable}
\begin {proof}

We prove this lemma by contradiction. Assume that there exists a value, such that $\textit{UVSet}(e,x)$ contains only its $\textit{put}$ and does not contain its $\textit{rm}$. Then we can see that there exists $d_1,\ldots,d_j$. Intuitively, $d_1,\ldots,d_j$ are elements in $\textit{UVSet}_1(e,x), \ldots, \textit{UVSet}_i(e,x)$, respectively. $\textit{UVSet}(e,x)$ contains $\textit{put}(d_j,\_)$ and does not contain $\textit{rm}(d_j)$. And each $d_i$ is the reason of $d_{\textit{i+1}} \in \textit{UVSet}_{\textit{i+1}}(e,x)$. Formally, we require that

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] For each $1 \leq i \leq j$, method events of $d_i$ belongs to $\textit{UVSet}_i(e,x)$.

\item[-] For each $i \neq j$, $\textit{put}(d_i,\_),\textit{rm}(d_i) \in \textit{UVSet}_i(e,x)$. $\textit{put}(d_j,\_) \in \textit{UVSet}_j(e,x)$, and $e$ does not contain $\textit{rm}(d_j)$.

\item[-] An operation of $d_1$ happens before an operations of $x$. For each $1 < i \leq j$, an operation of $d_i$ happens an operation of $d_{\textit{i-1}}$.

\item[-] For each $k$ and $\textit{ind}$, if $k > \textit{ind+1}$, then no operation of $d_k$ happens before operation of $d_{\textit{ind}}$.
\end{itemize}

According to the definition of $\textit{UVSet}(e,x)$, it is easy to see that such $d_1,\ldots,d_j$ exists. Let us prove the following fact:

\noindent {\bf $\textit{fact}_1$}: Given $1 \leq i < j$, it can not be the case that $\textit{put}(d_i,\_)$ and $\textit{rm}(d_i)$ overlap.

Proof of $\textit{fact}_1$: We prove $\textit{fact}_1$ by contradiction. Assume that for some $i \neq j$, $\textit{put}(d_i,\_)$ and $\textit{rm}(d_i)$ overlap. Since $\textit{put}(d_i,\_), \textit{rm}(d_i) \in \textit{UVSet}_i(h,x)$, we know that an operation $o_i$ of $d_i$ happens before operation $o_{\textit{i-1}}$ of $d_{\textit{i-1}}$. Moreover, since $\textit{put}(d_i,\_)$ and $\textit{rm}(d_i)$ overlap, it is not hard to see that the call action of $\textit{put}(d_i,\_)$ and the call action of $\textit{rm}(d_i)$ is before the call action of $o_{\textit{i-1}}$. Since method events of $d_{\textit{i+1}}$ is in $\textit{UVSet}_{\textit{i+1}}(e,x)$, we know that an operation $o'_{\textit{i+1}}$ of $d_{\textit{i+1}}$ happens before operation $o'_i$ of $d_i$. Then, it is not hard to see that $o'_{\textit{i+1}}$ also happens before $o_{\textit{i-1}}$, which contradicts that for each $k > \textit{ind+1}$, no operation of $d_k$ happens before operation of $d_{\textit{ind}}$.

We already know that an operation of $d_1$ happens before an operation of $x$. By $\textit{fact}_1$, we can ensure that $\textit{put}(d_1,\_)$ happens before an operation of $x$, and then $d_1 \rightarrow x$ in $G$. For each $1 < i \leq j$, we know that an operation $o_i$ of $d_i$ happens before an operation $o_{\textit{i-1}}$ of $d_{\textit{i-1}}$. By $\textit{fact}_1$, we can ensure that $o_i=\textit{put}(d_i,\_)$ and $o_{\textit{i-1}}=\textit{rm}(d_{\textit{i-1}})$, and then $d_i \rightarrow d_{\textit{i-1}}$ in $G$. Since $h$ contains $\textit{put}(d_j,\_)$ and does not contain $\textit{rm}(d_j)$, we know that $x \rightarrow d_j$ in $G$. Then $G$ has a cycle going through $x$, contradicts that $G$ has no cycle going through $x$. \qed
\end {proof}


The following lemma states that $\textit{UVSet}(e,x)$ does not happen before $\textit{rm}(x)$ when the left-right constraint has no cycle going through $x$.

\begin{restatable}{lemma}{RmxDoesNotHappenBeforeUVSetForPQ1Lar}
\label{lemma:Rmx does not happen before UVSet for PQ1Lar}

Given a data-differentiated execution $e$ with $\textit{last}(e) = \textit{PQ}_1^{>}$. Let $\textit{put}(x,\textit{pri}_x)$ and $\textit{rm}(x)$ be method events of $e$ with maximal priority. Let $G$ be the graph representing the left-right constraint of $\textit{put}(x,\textit{pri}_x)$ and $\textit{rm}(x)$. Assume that $G$ has no cycle going through $x$. Then, $\textit{rm}(x)$ does not happen before any operation in $\textit{UVSet}(e,x)$.
\end{restatable}

\begin {proof}

We prove this lemma by induction, and prove that $\textit{rm}(x)$ does not happen before any operation in $\textit{UVSet}_1(e,x)$, in $\textit{UVSet}_2(e,x)$, $\ldots$. Note that, by Lemma \ref{lemma:UVSet has matched put and rm}, $\textit{UVSet}(e,x)$ contains only matched $\textit{put}$ and $\textit{rm}$, and it is easy to see that for each $i$, $\textit{UVSet}_i(e,x)$ contains only matched $\textit{put}$ and $\textit{rm}$.

\noindent (1) Let us prove that $\textit{rm}(x)$ does not happen before any operation in $\textit{UVSet}_1(e,x)$ by contradiction. Assume that $\textit{rm}(x) <_{hb} o$, where $o \in \textit{UVSet}_1(e,x)$ is an operation of item $d$. %(according to the definition of $\textit{UVSet}_1(h,x)$, the priority of $d$ does not equals $\textit{pri}_x$).

We use a triple $(t_1,t_2,t_3)$ to represent related information. $t_1,t_2,t_3$ are chosen from $\{ \textit{put},\textit{rm} \}$. $t_1$ represents whether $o$ is a $\textit{put}$ method event or a $\textit{rm}$ method event. $t_2$ and $t_3$ is used for the reason of $o \in \textit{UVSet}_1(e,x)$: $o \in \textit{UVSet}_1(e,x)$, since an operation (of kind $t_2$) of $d$ happens before an operation (of kind $t_3$) of $x$. Let us consider all the possible cases of $(t_1,t_2,t_3)$:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $(\textit{put},\textit{put},\textit{put})$: Then $\textit{rm}(x) <_{hb} \textit{put}(d,\_) <_{hb} \textit{put}(x,\textit{pri}_x)$, contradicts that $\textit{rm}(x)$ does not happen before $\textit{put}(x,\textit{pri}_x)$.

\item[-] $(\textit{put},\textit{put},\textit{rm})$: Then $\textit{rm}(x) <_{hb} \textit{put}(d,\_) <_{hb} \textit{rm}(x)$, contradicts that $\textit{rm}(x)$ does not happen before $\textit{rm}(x)$.

\item[-] $(\textit{put},\textit{rm},\textit{put})$: Then $( \textit{rm}(x) <_{hb} \textit{put}(d,\_) ) \wedge ( \textit{rm}(d) <_{hb} \textit{put}(x,\textit{pri}_x) )$. By interval order, we know that $( \textit{rm}(x) <_{hb} \textit{put}(x,\textit{pri}_x) ) \vee ( \textit{rm}(d) <_{hb} \textit{put}(d,\_) )$, which is impossible.

\item[-] $(\textit{put},\textit{rm},\textit{rm})$: Then $( \textit{rm}(x) <_{hb} \textit{put}(d,\_) ) \wedge ( \textit{rm}(d) <_{hb} \textit{rm}(x) )$. We can see that $\textit{rm}(d) <_{hb} \textit{rm}(x) <_{hb} \textit{put}(d,\_)$, which contradicts that $\textit{rm}(d)$ does not happen before $\textit{put}(d,\_)$.

\item[-] $(\textit{rm},\textit{put},\textit{put})$: Then $( \textit{rm}(x) <_{hb} \textit{rm}(d) ) \wedge ( \textit{put}(d,\_) <_{hb} \textit{put}(x,\textit{pri}_x) )$. We can see that $x$ and $d$ has circle in $G$, contradicts that $G$ has no cycle going through $x$.

\item[-] $(\textit{rm},\textit{put},\textit{rm})$: Then $( \textit{rm}(x) <_{hb} \textit{rm}(d) ) \wedge ( \textit{put}(d,\_) <_{hb} \textit{rm}(x) )$. We can see that $x$ and $d$ has circle in $G$, contradicts that $G$ has no cycle going through $x$.

\item[-] $(\textit{rm},\textit{rm},\textit{put})$: Then $\textit{rm}(x) <_{hb} \textit{rm}(d) <_{hb} \textit{put}(x,\textit{pri}_x)$, contradicts that $\textit{rm}(x)$ does not happen before $\textit{put}(x,\textit{pri}_x)$.

\item[-] $(\textit{rm},\textit{rm},\textit{rm})$: Then $\textit{rm}(x) <_{hb} \textit{rm}(d) <_{hb} \textit{rm}(x)$, contradicts that $\textit{rm}(x)$ does not happen before $\textit{rm}(x)$.
\end{itemize}

This completes the proof for $\textit{UVSet}_1(e,x)$.

\noindent (2) Assume we already prove that for some $j \geq 1$, $\textit{rm}(x)$ does not happen before any operation in $\textit{UVSet}_1(e,x) \cup \ldots \cup \textit{UVSet}_j(e,x)$. Let us prove that $\textit{rm}(x)$ does not happen before any operation in $\textit{UVSet}_{\textit{j+1}}(e,x)$ by contradiction. Assume that $\textit{rm}(x) <_{hb} o$, where $o \in \textit{UVSet}_{\textit{j+1}}(e,x)$ is an operation of item $d_{\textit{j+1}}$. We use a triple $(t_1,t_2,t_3)$ to represent related information. $t_1,t_2,t_3$ are chosen from $\{ \textit{put},\textit{rm} \}$. $t_1$ represents whether $o$ is a $\textit{put}$ method event or a $\textit{rm}$ method event. $t_2$ and $t_3$ is used for the reason of $o \in \textit{UVSet}_{\textit{j+1}}(e,x)$: $o \in \textit{UVSet}_{\textit{j+1}}(e,x)$, since an operation (of kind $t_2$) of $d_{\textit{j+1}}$ happens before an operation (of kind $t_3$) of $d_j$, where $\textit{put}(d_j,\_), \textit{rm}(d_j) \in \textit{UVSet}_j(e,x)$. Let us consider all the possible cases of $(t_1,t_2,t_3)$:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $(\textit{put},\textit{put},\textit{put})$: Then $\textit{rm}(x) <_{hb} \textit{put}(d_{\textit{j+1}},\_) <_{hb} \textit{put}(d_j,\_)$. We can see that $( \textit{rm}(x) <_{hb} \textit{put}(d_j,\_) ) \wedge ( \textit{put}(d_j,\_) \in \textit{UVSet}_j(e,x) )$, which contradicts that $\textit{rm}(x)$ does not happen before any operation in $\textit{UVSet}_1(e,x) \cup \ldots \cup \textit{UVSet}_j(e,x)$.

\item[-] $(\textit{put},\textit{put},\textit{rm})$: Then $\textit{rm}(x) <_{hb} \textit{put}(d_{\textit{j+1}},\_) <_{hb} \textit{rm}(d_j,\_)$. We can see that $( \textit{rm}(x) <_{hb} \textit{rm}(d_j,\_) ) \wedge ( \textit{rm}(d_j) \in \textit{UVSet}_j(e,x) )$, which contradicts that $\textit{rm}(x)$ does not happen before any operation in $\textit{UVSet}_1(e,x) \cup \ldots \cup \textit{UVSet}_j(e,x)$.

\item[-] $(\textit{put},\textit{rm},\textit{put})$: Then $( \textit{rm}(x) <_{hb} \textit{put}(d_{\textit{j+1}},\_) ) \wedge ( \textit{rm}(d_{\textit{j+1}}) <_{hb} \textit{put}(d_j,\_) )$. By interval order, we know that $( \textit{rm}(x) <_{hb} \textit{put}(d_j,\_) ) \vee ( \textit{rm}(d_{\textit{j+1}}) <_{hb} \textit{put}(d_{\textit{j+1}},\_) )$, which is impossible.

\item[-] $(\textit{put},\textit{rm},\textit{rm})$: Then $( \textit{rm}(x) <_{hb} \textit{put}(d_{\textit{j+1}},\_) ) \wedge ( \textit{rm}(d_{\textit{j+1}}) <_{hb} \textit{rm}(d_j) )$. By interval order, we know that $( \textit{rm}(x) <_{hb} \textit{rm}(d_j) ) \vee ( \textit{rm}(d_{\textit{j+1}}) <_{hb} \textit{put}(d_{\textit{j+1}},\_) )$, which is impossible.

\item[-] $(\textit{rm},\textit{put},\textit{put})$: Then $( \textit{rm}(x) <_{hb} \textit{rm}(d_{\textit{j+1}}) ) \wedge ( \textit{put}(d_{\textit{j+1}},\_) <_{hb} \textit{put}(d_j,\_) )$. Let us consider the reason of $\textit{put}(d_j,\_), \textit{rm}(d_j) \in \textit{UVSet}_j(e,x)$:
    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] If $( j > 1 ) \wedge ( \textit{put}(d_j,\_) <_{hb} o'' )$, where $o''$ is an operation of item $d_{\textit{j-1}}$ and $\textit{put}(d_{\textit{j-1}},\_), \textit{rm}(d_{\textit{j-1}}) \in \textit{UVSet}_{\textit{j-1}}(e,x)$: Then since $( \textit{put}(d_{\textit{j+1}},\_) <_{hb} \textit{put}(d_j,\_) ) \wedge ( \textit{put}(d_j,\_) <_{hb} o'' )$, we can see that $\textit{put}(d_{\textit{j+1}},\_) <_{hb} o''$, and then operations of $d_{\textit{j+1}}$ is in $\textit{UVSet}_j(e,x)$, contradicts that operations of $d_{\textit{j+1}}$ is in $\textit{UVSet}_{\textit{j+1}}(e,x)$.

    \item[-] If $( j = 1 ) \wedge ( \textit{put}(d_j,\_) <_{hb} o'' )$, where $o''$ is an operation of $x$: Similar to above case.

    \item[-] If $( j > 1 ) \wedge ( \textit{rm}(d_j) <_{hb} o'' )$, where $o''$ is an operation of item $d_{\textit{j-1}}$ and $\textit{put}(d_{\textit{j-1}},\_), \textit{rm}(d_{\textit{j-1}}) \in \textit{UVSet}_{\textit{j-1}}(e,x)$: Then since $( \textit{put}(d_{\textit{j+1}},\_) <_{hb} \textit{put}(d_j,\_) ) \wedge ( \textit{rm}(d_j) <_{hb} o'' )$, we can see that $( \textit{put}(d_{\textit{j+1}},\_) <_{hb} o'' ) \vee ( \textit{rm}(d_j) <_{hb} \textit{put}(d_j,\_) )$, which is impossible.

    \item[-] If $( j > 1 ) \wedge ( \textit{rm}(d_j) <_{hb} o'' )$, where $o''$ is an operation of $x$: Similar to above case.
    \end{itemize}

\item[-] $(\textit{rm},\textit{put},\textit{rm})$: Let $T_{\textit{ind}}$ be the set of sentences $\{ \textit{rm}(x) <_{hb} \textit{rm}(d_{\textit{j+1}}), \textit{put}(d_{\textit{j+1}},\_) <_{hb} \textit{rm}(d_j),\ldots, \textit{put}(d_{\textit{ind+1}},\_) <_{hb} \textit{rm}(d_{\textit{ind}}) \}$. Here each $d_i$ is a item of some operation in $\textit{UVSet}_i(e,x)$. Let us prove that from $T_j$ we can obtain contradiction by induction:

    {\bf Base case $1$}: From $T_1$ we can obtain contradiction.

    Let us prove base case $1$:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] If $\textit{put}(d_1,\_)$ happens $o$, and $o$ is an operation of $x$. Then there is a cycle $x \rightarrow d_{\textit{j+1}} \rightarrow \ldots \rightarrow d_1 \rightarrow x$ in $G$, contradicts that $G$ has no cycle going through $x$.

    \item[-] If $\textit{rm}(d_1)$ happens before $o$, and $o$ is an operation of $x$. Then since $\textit{put}(d_2,\_) <_{hb} \textit{rm}(d_1)$ and $\textit{rm}(d_1) <_{hb} o$, we can see that $\textit{put}(d_2,\_) <_{hb} o$, and then $\textit{put}(d_2,\_) \in \textit{UVSet}_1(e,x)$, contradicts that $\textit{put}(d_2,\_) \in \textit{UVSet}_2(e,x)$.
    \end{itemize}

    {\bf Base case $2$}: From $T_2$ we can obtain contradiction.

    Let us prove base case $2$: If $\textit{rm}(d_2) <_{hb} o$, and $o$ is an operation of $d_1$, then since $( \textit{put}(d_3,\_) <_{hb} \textit{rm}(d_2) ) \wedge ( \textit{rm}(d_2) <_{hb} o )$, we know that $\textit{put}(d_3,\_) <_{hb} o$. This implies that $\textit{put}(d_3,\_) \in \textit{UVSet}_2(e,x)$, contradicts that $\textit{rm}(d_3,\_) \in \textit{UVSet}_3(e,x)$. Therefore, it is only possible that $\textit{put}(d_2,\_)$ happens before an operation of $d_1$.

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] If $\textit{put}(d_2,\_) <_{hb} \textit{put}(d_1,\_)$ and $\textit{put}(d_1,\_)$ happens before operations of $x$, then we know that $\textit{put}(d_2,\_)$ happens before operation of $x$, which is impossible.

    \item[-] If $\textit{put}(d_2,\_) <_{hb} \textit{put}(d_1,\_)$ and $\textit{rm}(d_1)$ happens before operations of $x$, then by interval order, we know that $\textit{put}(d_2,\_)$ happens before operation of $x$, or $\textit{rm}(d_1) <_{hb} \textit{put}(d_1,\_)$, which is impossible.

    \item[-] If $\textit{put}(d_2,\_) <_{hb} \textit{rm}(d_1)$ and $\textit{put}(d_1,\_)$ happens before operations of $x$, then $x \rightarrow d_{\textit{j+1}} \rightarrow \ldots \rightarrow d_1 \rightarrow x$ in $G$, contradicts that $G$ has no cycle going through $x$.

    \item[-] If $\textit{put}(d_2,\_) <_{hb} \textit{rm}(d_1)$ and $\textit{rm}(d_1)$ happens before operations of $x$, then we know that $\textit{put}(d_2,\_)$ happens before operation of $x$, which is impossible.
    \end{itemize}

    {\bf induction step}: Given $\textit{ind} \geq 3$, if from $T_{\textit{ind-1}}$ we can obtain contradiction, then from $T_{\textit{ind}}$ we can also contain contradiction.


    Prove of the induction step: Similarly as base case $2$, we can prove that it is only possible that $\textit{put}(d_{\textit{ind}},\_)$ happens before operations of $d_{\textit{ind-1}}$.

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] If $\textit{put}(d_{\textit{ind}},\_) <_{hb} \textit{put}(d_{\textit{ind-1}},\_)$ and $\textit{put}(d_{\textit{ind-1}},\_)$ happens before operations of $d_{\textit{ind-2}}$, then we know that $\textit{put}(d_{\textit{ind}})$ happens before operation of $d_{\textit{ind-2}}$, which is impossible.

    \item[-] If $\textit{put}(d_{\textit{ind}},\_) <_{hb} \textit{put}(d_{\textit{ind-1}},\_)$ and $\textit{rm}(d_{\textit{ind-1}})$ happens before operations of $d_{\textit{ind-2}}$, then by interval order, we know that $\textit{put}(d_{\textit{ind}},\_)$ happens before operation of $d_{\textit{ind-2}}$, or $\textit{rm}(d_{\textit{ind-1}}) <_{hb} \textit{put}(d_{\textit{ind-1}},\_)$, which is impossible.

    \item[-] If $\textit{put}(d_{\textit{ind}},\_) <_{hb} \textit{rm}(d_{\textit{ind-1}})$, then we obtain $T_{\textit{ind-1}}$, which already contain contradiction.
    \end{itemize}

    By base case $1$, base case $2$ and the induction step, it is easy to see that for each $i$, $T_i$ contains contradiction. Therefore, $T_j$, the case of $(\textit{rm},\textit{put},\textit{rm})$, contains contradiction.

\item[-] $(\textit{rm},\textit{rm},\textit{put})$: Then $( \textit{rm}(x) <_{hb} \textit{rm}(d_{\textit{j+1}}) ) \wedge ( \textit{rm}(d_{\textit{j+1}}) <_{hb} \textit{put}(d_j,\_) )$. We can see that $( \textit{rm}(x) <_{hb} \textit{put}(d_j,\_) ) \wedge ( \textit{put}(d_j,\_) \in \textit{UVSet}_j(e,x) )$, which contradicts that $\textit{rm}(x)$ does not happen before any operation in $\textit{UVSet}_1(e,x) \cup \ldots \cup \textit{UVSet}_j(e,x)$.

\item[-] $(\textit{rm},\textit{rm},\textit{rm})$: Then $( \textit{rm}(x) <_{hb} \textit{rm}(d_{\textit{j+1}}) ) \wedge ( \textit{rm}(d_{\textit{j+1}}) <_{hb} \textit{rm}(d_j) )$. We can see that $( \textit{rm}(x) <_{hb} \textit{rm}(d_j) ) \wedge ( \textit{rm}(d_j) \in \textit{UVSet}_j(e,x) )$, which contradicts that $\textit{rm}(x)$ does not happen before any operation in $\textit{UVSet}_1(e,x) \cup \ldots \cup \textit{UVSet}_j(e,x)$.
\end{itemize}

This completes the proof for $\textit{UVSet}_{\textit{j+1}}(e,x)$. Therefore, $\textit{rm}(x)$ does not happen before any operation in $\textit{UVSet}(e,x) = \textit{UVSet}_1(e,x) \cup \textit{UVSet}_2(e,x) \cup \ldots$. \qed
\end {proof}

With Lemma \ref{lemma:UVSet has matched put and rm} and Lemma \ref{lemma:Rmx does not happen before UVSet for PQ1Lar}, we can now prove Lemma \ref{lemma:Lin Equals Constraint for PQ1Lar}.

\LinEqualsConstraintforPQOneLar*

\begin {proof}

To prove the $\textit{only if}$ direction, assume that $e \sqsubseteq \textit{MS}(\textit{PQ}_1^{>})$. Let $u$, $v$ and $w$ be the sequences of method events in $\textit{PQ}_1^{>}$, and let $U$, $V$ and $W$ be the set of method events of $u$, $v$ and $w$, respectively. Assume by contradiction that, there is a cycle $d_1 \rightarrow d_2 \rightarrow \ldots \rightarrow d_m \rightarrow x \rightarrow d_1$ in $G$. It is obvious that the priority of each $d_i$ is less than $\textit{pri}_x$. Then our proof proceeds as follows:

According to the definition of left-right constraint, there are two possibilities. The first possibility is that, $\textit{rm}(x)$ happens before $\textit{rm}(d_1)$. It is obvious that $\textit{rm}(d_1) \in W$, and then since $U \cup V$ contains matched $\textit{put}$ and $\textit{rm}$, we can see that $\textit{put}(d_1),\textit{rm}(d_1) \in W$. Then,

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Since $d_1 \rightarrow d_2$, by definition of $G$, we know that $\textit{put}(d_1)$ happens before $\textit{rm}(d_2)$. Since $\textit{put}(d_1) \in W$ and $U \cup V$ contains matched $\textit{put}$ and $\textit{rm}$, we know that $\textit{put}(d_2),\textit{rm}(d_2) \in W$. Similarly, for each $1 \leq i \leq m$, we know that $\textit{put}(d_i),\textit{rm}(d_i) \in W$.

\item[-] Since $d_m \rightarrow x$,
    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] if $\textit{put}(d_m)$ happens before $\textit{put}(x)$, then we can see that $\textit{put}(d_m) \in U$, which contradicts that $\textit{put}(d_m) \in W$.

    \item[-] if $\textit{put}(d_m)$ happens before $\textit{rm}(x)$, then we can see that $\textit{put}(d_m) \in U \cup V$, which contradicts that $\textit{put}(d_m) \in W$.
    \end{itemize}
\end{itemize}

The second possibility is that, $e$ contains one $\textit{put}(d_1,\_)$ and no $\textit{rm}(d_1)$. Note that for each $j > 1$, $e$ contains $\textit{put}(d_j,\_)$ and $\textit{rm}(d_j)$. Since $d_m \rightarrow x$, is is obvious that $\textit{put}(d_m) \in U \cup V$. Since $U \cup V$ contains matched $\textit{put}$ and $\textit{rm}$, we know that $\textit{put}(d_m),\textit{rm}(d_m) \in U \cup V$. Then, since $d_{\textit{m-1}} \rightarrow d_m$, by definition of $G$, we know that $\textit{put}(d_{\textit{m-1}})$ happens before $\textit{rm}(d_m)$. Since $\textit{rm}(d_m) \in U \cup V$ and $U \cup V$ contains matched $\textit{put}$ and $\textit{rm}$, we know that $\textit{put}(d_{\textit{m-1}}),\textit{rm}(d_{\textit{m-1}}) \in U \cup V$. Similarly, for each $1 < i \leq m$, we know that $\textit{put}(d_i),\textit{rm}(d_i) \in U \cup V$, and also $\textit{put}(d_1)\in U \cup V$. However, there is one $\textit{put}(d_1,\_)$ and no $\textit{rm}(d_1)$ in $e$, contradicts that $U \cup V$ contains matched $\textit{put}$ and $\textit{rm}$.

This completes the proof of the $\textit{only if}$ direction.

To prove the $\textit{if}$ direction, assume that $G$ has no cycle going through $x$. Let $E_u$ be the set of operations that happen before $\textit{put}(x)$ in $e$. It is easy to see that $E_u \subseteq \textit{UVSet}(e,x)$. Let $E_v = \textit{UVSet}(e,x) \setminus E_u$. Let $E_e$ be the set of operations of $e$, and let $E_w = E_e \setminus \textit{UVSet}(e,x)$.

By Lemma \ref{lemma:UVSet has matched put and rm}, we can see that $E_u \cup E_v$ contains matched $\textit{put}$ and $\textit{rm}$ operations. It remains to prove that for $E_u$, $\{ \textit{put}(x,\textit{pri}_x) \}$, $E_v$, $\{ \textit{rm}(x) \}$, $E_w$, no elements of the latter set happens before elements of the former set. We prove this by showing that all the following cases are impossible:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Case $1$: Some operation $o_w \in E_w$ happens before $\textit{rm}(x)$. Then we know that $o_w \in \textit{UVSet}(e,x) = E_u \cup E_v$, which contradicts that $o_w \in E_w$.

\item[-] Case $2$: Some operation $o_w \in E_w$ happens before some operation $o_{\textit{uv}} \in E_u \cup E_v$. Then we know that $o_w \in \textit{UVSet}(e,x) = E_u \cup E_v$, which contradicts that $o_w \in E_w$.

\item[-] Case $3$: Some operation $o_w \in E_w$ happens before $\textit{put}(x)$. Then we know that $o_w \in \textit{UVSet}(e,x) = E_u \cup E_v$, which contradicts that $o_w \in E_w$.

\item[-] Case $4$: $\textit{rm}(x)$ happens before some $o_{\textit{uv}} \in \textit{UVSet}(e,x) = E_u \cup E_v$. By Lemma \ref{lemma:Rmx does not happen before UVSet for PQ1Lar} we know that this is impossible.

\item[-] Case $5$: $\textit{rm}(x)$ happens before $\textit{put}(x)$. This contradicts that each single-priority projection satisfy the FIFO property.

\item[-] Case $6$: Some operation $o_v \in E_v$ happens before $\textit{put}(x)$. Then we know that $o_v \in E_u$, which contradicts that $o_v \in E_v$.

\item[-] Case $7$: Some operation $o_v \in E_v$ happens before some operation $o_u \in E_u$. Then we know that $o_v \in E_u$, which contradicts that $o_v \in E_v$.

\item[-] Case $8$: $\textit{put}(x)$ happens before some operation $o_u \in E_u$. This is impossible.
\end{itemize}

This completes the proof of the $\textit{if}$ direction.

\qed
\end {proof}


Let us begin to represent witness automata that is used for capture the existence of a data-differentiated execution $e$, $e$ has a projection $e'$, $\textit{last}(e') = \textit{PQ}_1^{>}$, and there exists a cycle going through the item with maximal priority in $e'$. By data-independence, we can obtain $e_r$ from $e$ by renaming function, which maps such item to be $b$, maps items that cover it to be $a$, and maps other items into $d$. There are four possible enumeration of call and return actions of $\textit{put}(b)$ and $\textit{rm}(b)$. For each of them, we generate a witness automaton.

For the case when $e_r \vert_{b} = \textit{cal}(\textit{put},b,p) \cdot \textit{ret}(\textit{put}) \cdot \textit{cal}(\textit{rm}) \cdot \textit{ret}(\textit{rm},b)$, we generate witness automaton $\mathcal{A}_{\textit{l-lar}}^1$, as shown in \figurename~\ref{fig:automata APQ1Lar-1}. Here $c_1 = c + \textit{ret}(\textit{rm},a)$, $c_2 = c + \textit{cal}(\textit{put},a,\textit{les}_p)$, $c_3 = c_2 + \textit{ret}(\textit{rm},a)$, where $c = \textit{cal}(\textit{put},d,\textit{anyPri}),\textit{ret}(\textit{put},d), \textit{cal}(\textit{rm},d), \textit{ret}(\textit{rm},d)$. The differentiated branch in $\mathcal{A}_{\textit{l-lar}}^1$ comes from the positions of the first $\textit{ret}(\textit{put},a)$.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=1 \textwidth]{figures/PIC_AUTO_PQ1Lar-pprr.pdf}
%\vspace{-10pt}
  \caption{Automaton $\mathcal{A}_{\textit{l-lar}}^1$}
  \label{fig:automata APQ1Lar-1}
\end{figure}

$\mathcal{A}_{\textit{l-lar}}^1$ is used to recognize conditions in \figurename~\ref{fig:his for APQ1Lar-1}. Here for simplicity, we only draw operation of $b$, and the return action of the first call of $\textit{ret}(\textit{put},a)$.


\begin{figure}[htbp]
  \centering
  \includegraphics[width=1 \textwidth]{figures/PIC_HIS_PQ1Lar-pprr.pdf}
%\vspace{-10pt}
  \caption{Conditions recognized by $\mathcal{A}_{\textit{l-lar}}^1$}
  \label{fig:his for APQ1Lar-1}
\end{figure}


For the case when $e_r \vert_{b} = \textit{cal}(\textit{put},b,p) \cdot \textit{cal}(\textit{rm}) \cdot \textit{ret}(\textit{put}) \cdot \textit{ret}(\textit{rm},b)$, we generate witness automaton $\mathcal{A}_{\textit{l-lar}}^2$, as shown in \figurename~\ref{fig:automata APQ1Lar-2}. Here $c_1,c_2,c_3$ is the same as that in $\mathcal{A}_{\textit{l-lar}}^1$. The differentiated branch in $\mathcal{A}_{\textit{l-lar}}^2$ comes from the positions of the first $\textit{ret}(\textit{put},a)$.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=1 \textwidth]{figures/PIC_AUTO_PQ1Lar-prpr.pdf}
%\vspace{-10pt}
  \caption{Automaton $\mathcal{A}_{\textit{l-lar}}^2$}
  \label{fig:automata APQ1Lar-2}
\end{figure}


$\mathcal{A}_{\textit{l-lar}}^2$ is used to recognize conditions in \figurename~\ref{fig:his for APQ1Lar-2}. Here for simplicity, we only draw operation of $b$, and the return action of the first call of $\textit{ret}(\textit{put},a)$.


\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7 \textwidth]{figures/PIC_HIS_PQ1Lar-prpr.pdf}
%\vspace{-10pt}
  \caption{Conditions recognized by $\mathcal{A}_{\textit{l-lar}}^2$}
  \label{fig:his for APQ1Lar-2}
\end{figure}

For the case when $e_r \vert_{b} = \textit{cal}(\textit{rm}) \cdot \textit{cal}(\textit{put},b,p) \cdot \textit{ret}(\textit{put}) \cdot \textit{ret}(\textit{rm},b)$, we generate witness automaton $\mathcal{A}_{\textit{l-lar}}^3$, as shown in \figurename~\ref{fig:automata APQ1Lar-3}. Here $c_1,c_2,c_3$ is the same as that in $\mathcal{A}_{\textit{l-lar}}^1$. The differentiated branch in $\mathcal{A}_{\textit{l-lar}}^3$ comes from the positions of the first $\textit{ret}(\textit{put},a)$.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=1 \textwidth]{figures/PIC_AUTO_PQ1Lar-rppr.pdf}
%\vspace{-10pt}
  \caption{Automaton $\mathcal{A}_{\textit{l-lar}}^3$}
  \label{fig:automata APQ1Lar-3}
\end{figure}


$\mathcal{A}_{\textit{l-lar}}^3$ is used to recognize conditions in \figurename~\ref{fig:his for APQ1Lar-3}. Here for simplicity, we only draw operation of $b$, and the return action of the first call of $\textit{ret}(\textit{put},a)$.


\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7 \textwidth]{figures/PIC_HIS_PQ1Lar-rppr.pdf}
%\vspace{-10pt}
  \caption{Conditions recognized by $\mathcal{A}_{\textit{l-lar}}^3$}
  \label{fig:his for APQ1Lar-3}
\end{figure}


For the case when $e_r \vert_{b} = \textit{cal}(\textit{rm}) \cdot \textit{cal}(\textit{put},b,p) \cdot \textit{ret}(\textit{rm},b) \cdot \textit{ret}(\textit{put})$, we generate witness automaton $\mathcal{A}_{\textit{l-lar}}^4$, as shown in \figurename~\ref{fig:automata APQ1Lar-4}. Here $c_1,c_2,c_3$ is the same as that in $\mathcal{A}_{\textit{l-lar}}^1$. The differentiated branch in $\mathcal{A}_{\textit{l-lar}}^4$ comes from the positions of the first $\textit{ret}(\textit{put},a)$.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.9 \textwidth]{figures/PIC_AUTO_PQ1Lar-rprp.pdf}
%\vspace{-10pt}
  \caption{Automaton $\mathcal{A}_{\textit{l-lar}}^4$}
  \label{fig:automata APQ1Lar-4}
\end{figure}


$\mathcal{A}_{\textit{l-lar}}^4$ is used to recognize conditions in \figurename~\ref{fig:his for APQ1Lar-4}. Here for simplicity, we only draw operation of $b$, and the return action of the first call of $\textit{ret}(\textit{put},a)$.


\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.7 \textwidth]{figures/PIC_HIS_PQ1Lar-rprp.pdf}
%\vspace{-10pt}
  \caption{Conditions recognized by $\mathcal{A}_{\textit{l-lar}}^4$}
  \label{fig:his for APQ1Lar-4}
\end{figure}

Let $\textit{Auts}_{\textit{1-lar}} = \{ \mathcal{A}_{\textit{l-lar}}^1, \mathcal{A}_{\textit{l-lar}}^2, \mathcal{A}_{\textit{l-lar}}^3, \mathcal{A}_{\textit{l-lar}}^4 \}$. The following lemma states that $\textit{PQ}_1^{>}$ is co-regular.


\PQOneLarisCoRegular*

\begin {proof}

We need to prove that, given a data-independence implementation $\mathcal{I}$, $\textit{Auts}_{\textit{1-lar}} \cap \mathcal{I} = \emptyset$ if and only if $\exists e \in \mathcal{I}_{\neq},e' \in \textit{proj}(e), last(e')=\textit{PQ}_1^{>} \wedge e$ does not linearizable w.r.t. $\textit{MS}(\textit{PQ}_1^{>})$.

By Lemma \ref{lemma:Lin Equals Constraint for PQ1Lar}, we need to prove the following fact:

\noindent {\bf $\textit{fact}_1$}: Given a data-independence implementation $\mathcal{I}$, $\textit{Auts}_{\textit{1-lar}} \cap \mathcal{I} = \emptyset$ if and only if $\exists e \in \mathcal{I}_{\neq},e' \in \textit{proj}(e), last(e')=\textit{PQ}_1^{>} \wedge$ there is a cycle going through $x$ in $G$, where $G$ is the left-right constraint of $e'$, and $x$ is the item with maximal priority in $e'$.

\noindent The $\textit{only if}$ direction: Let us consider the case of $\mathcal{A}_{\textit{l-lar}}^1$. Assume that $e_1 \in \mathcal{I}$ is accepted by $\mathcal{A}_{\textit{l-lar}}^1$. By data-independence, there exists data-differentiated execution $e \in \mathcal{I}$ and renaming function $r_1$, such that $e_1 = r_1(e)$. Assume that $r_1$ maps $d$ into $b$ and maps $f_1,\ldots,f_m$ into $a$. Let $e'$ be obtained from $e$ by projection into $\{ d, f_1,\ldots,f_m \}$. It is easy to see that $\textit{last}(\textit{PQ}_1^{>})$, and there is a cycle going through $d$ in $G$, where $G$ is the left-right constraint of $e'$. The case of $\mathcal{A}_{\textit{l-lar}}^2$, $\mathcal{A}_{\textit{l-lar}}^3$ and $\mathcal{A}_{\textit{l-lar}}^4$ is similar.

\noindent The $\textit{if}$ direction: Given such $e$, $e'$ and $x$. Let renaming function $r$ maps $x$ into $b$, maps items cover $x$ into $a$, and maps other items into $d$. By data-independence, $r(e) \in \mathcal{I}$. Then depending on the case of $r(e) \vert_{b}$, we can see that $r(e)$ is accepted by $\mathcal{A}_{\textit{l-lar}}^1$, $\mathcal{A}_{\textit{l-lar}}^2$, $\mathcal{A}_{\textit{l-lar}}^3$ or $\mathcal{A}_{\textit{l-lar}}^4$. \qed
\end {proof}



\subsection{Proofs and Definitions in Subsection \ref{subsec:co-regular of PQ1Equal}}
\label{sec:appendix proof and definition in section co-regular of PQ1Equal}

Let $\textit{Items}(e,p)$ be the set of items with priority $p$ in execution $e$. The following lemma states a method to choose $\textit{itm}$ of $\textit{PQ}_1^{=}$.

\begin{restatable}{lemma}{MaximalInPBadGPMakePQ1Equal}
\label{lemma:maximal in pb and gap-point make a candidate of PQ1Equal}
Given a data-differentiated execution $e$ with $\textit{last}(e) = \textit{PQ}_1^{=}$. Let $\textit{pri}$ be the maximal priority in $e$. If there exists an item $x$ with priority $\textit{pri}$, such that for each $y \in \textit{Items}(e,\textit{pri})$, (1) $x$ does not $<_{\textit{pb}}$ to $y$, and (2) the right-most gap-point of $x$ is after $\textit{cal}(\textit{put},y,\_)$ and $\textit{cal}(\textit{rm},y)$. Then $e \sqsubseteq \textit{MS}(\textit{PQ}_1^{=})$.
\end{restatable}

\begin {proof}

Let $o$ be the right-most gap-point of $x$. We locate linearization points of each method event as follows:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Locate the linearization point of $\textit{rm}(x)$ at $o$,

\item[-] If $\textit{put}(x,\textit{pri})$ overlaps with $\textit{rm}(x)$, then locate the linearization point of $\textit{put}(x,\textit{pri})$ just before the linearization point of $\textit{rm}(x)$. Otherwise, $\textit{put}(x,\textit{pri}) <_{\textit{hb}} \textit{rm}(x)$, and we locate the linearization point of $\textit{put}(x,\textit{pri})$ just before its return action.

\item[-] Locate linearization points of method event of each $y \in \textit{Items}(e,\textit{pri})$ (except for $x$) just after the call action of the method event.

\item[-] For item $z$ with priority smaller than $\textit{pri}$. If both $\textit{cal}(\textit{put},z,\_)$ and $\textit{cal}(\textit{rm},z)$ is before $o$, then locate the linearization points of $\textit{put}(z,\_)$ and $\textit{rm}(z)$ just after their call actions. If both $\textit{ret}(\textit{put},z)$ and $\textit{ret}(\textit{rm},z)$ (if exists) is after $o$, then locate the linearization points of $\textit{put}(z,\_)$ and $\textit{rm}(z)$ just before their return actions. Otherwise, $x$ is in interval of $z$, which contradicts the definition of gap-point.
\end{itemize}

Let $l$ be the sequence of linearization points constructed above. It is obvious that $e \sqsubseteq l$. Since for each $y \in \textit{Items}(e,\textit{pri})$, $o$ is after $\textit{cal}(\textit{put},y,\_)$ and $\textit{cal}(\textit{rm},x)$, we can see that $\textit{rm}(x)$ is after $\textit{put}(y,\textit{pri})$ and $\textit{rm}(y)$ in $l$. It is obvious that $\textit{put}(x,\textit{pri})$ is before $\textit{rm}(x)$ in $l$. Since $x$ does not $<_{\textit{pb}}$ to $y$, we can see that no $\textit{put}(y,\textit{pri})$ happens before $\textit{put}(x,\textit{pri})$. Then it is easy to see that $\textit{put}(x,\textit{pri})$ is after $\textit{put}(y,\textit{pri})$ in $l$. Since $\textit{last}(e) = \textit{PQ}_1^{=}$, all other items in $\textit{Items}(e,\textit{pri})$ has matched $\textit{put}$ and $\textit{rm}$, and it is easy to see that they are all before $\textit{rm}(x)$ in $l$.

For item $z$ with priority smaller than $\textit{pri}$, we can see that there are only two possibilities: (1) $\textit{put}(z,\_)$ and $\textit{rm}(z)$ are both before $\textit{rm}(x)$ in $l$, and (2) $\textit{put}(z,\_)$ and $\textit{rm}(z)$ (if exists) are after before $\textit{rm}(x)$ in $l$. Therefore, before $\textit{rm}(x)$ in $l$, the $\textit{put}$ and $\textit{rm}$ of $z$ are matched.

Therefore, it is easy to see that $l \in \textit{MS}(\textit{PQ}_1^{=})$. \qed
\end {proof}

With Lemma \ref{lemma:maximal in pb and gap-point make a candidate of PQ1Equal}, we can prove the following lemma, which states that getting rid of case in \figurename~\ref{fig:introduce pb order} is enough for ensure $\textit{last}(e) = \textit{PQ}_1^{=} \Rightarrow e \sqsubseteq \textit{MS}(\textit{PQ}_1^{=})$.


\PQOneEqualAsPBandGP*

\begin {proof}

To prove the $\textit{if}$ direction, let $e_{x,y}$ be the execution that is obtained from $e$ by erasing all actions of items that has same priority as $x$, except for actions of $x$ and $y$. It is obvious that $\textit{last}(e_{x,y}) = \textit{PQ}_1^{=}$. Since $y <_{\textit{pb}}^* x$, according to $\textit{PQ}_1^{=}$, we can see that $x$ should be chosen as $\textit{itm}$ in $\textit{PQ}_1^{=}$.

According to Lemma \ref{lemma:Lin Equals Constraint for PQ1Lar} (Here we temporarily forget the existence of $y$), the only possible position for locating linearizaton point of $\textit{rm}(x)$ is at gap-point of $x$. Otherwise, if the linearizaton point of $\textit{rm}(x)$ is chosen at a position that is not a gap-point of $x$, then there exists unmatched method event before $\textit{rm}(x)$ with smaller priority. Since the rightmost gap-point of $x$ is before $\textit{cal}(\textit{put},y,\_)$ or $\textit{cal}(\textit{rm},y)$, if we locate linearizaton point of $\textit{rm}(x)$ at gap-point of $x$, then $\textit{rm}(x)$ will be before $\textit{cal}(\textit{put},y,\_)$ or $\textit{cal}(\textit{rm},x)$.

Therefore, for every sequence $l = u \cdot \textit{put}(x,\_) \cdot v \cdot \textit{rm}(x) \cdot w$, if $e_{x,y} \sqsubseteq l$, then either $u \cdot v$ contains some unmatched method events of priority less than priority of $x$, or $w$ contains $\textit{put}(y,\_)$ or $\textit{rm}(y)$. In both cases, $l \notin \textit{MS}(\textit{PQ}_1^{=})$.

To prove the $\textit{only if}$ direction, we prove its contrapositive. Assume we already know that for each $x$ and $y$ has maximal priority in $e$, if $y <_{\textit{pb}}^* x$, then the rightmost gap-point of $x$ is after $\textit{cal}(\textit{put},y,\_)$ and $\textit{cal}(\textit{rm},x)$. We need to prove that $e \sqsubseteq \textit{MS}(\textit{PQ}_1^{=})$. Let $\textit{pri}$ be the maximal priority of $e$. Recall that we already assume that each single-priority execution has FIFO property, and item with larger priority is not covered by items with smaller priority.

Our proof proceed as follows:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Let $e_{\textit{pri}}$ be the projection of $e$ into operations of priority $\textit{pri}$. Since each single-priority execution has FIFO property, there exists sequence $l_{\textit{pri}}$, such that $e_{\textit{pri}} \sqsubseteq l_{\textit{pri}}$, and when we treat $\textit{put}$ as $\textit{enq}$ and $\textit{rm}$ as $\textit{deq}$, $l_{\textit{pri}}$ belongs to queue.

\item[-] Let $a_1$ be the last inserted item of $l_{\textit{pri}}$.

    Step $1$: Check whether for each $b \in \textit{Items}(e,\textit{pri})$, (1) $a_1$ does not $<_{\textit{pb}}$ to $b$, and (2) the right-most gap-point of $a$ is after $\textit{cal}(\textit{put},b,\textit{pri})$ and $\textit{cal}(\textit{rm},b)$.

    It is easy to see that $a_1$ is of priority $\textit{pri}$, and $a_1$ does not $<_{\textit{pb}}$ to any $b \in \textit{Items}(e,\textit{pri})$. If for each $b \in \textit{Items}(e,\textit{pri})$, the rightmost gap-point of $a_1$ is after $\textit{cal}(\textit{put},b,\textit{pri})$ and $\textit{cal}(\textit{rm},b)$. Then by Lemma \ref{lemma:maximal in pb and gap-point make a candidate of PQ1Equal}, we can obtain that $e \sqsubseteq \textit{MS}(\textit{PQ}_1^{=})$.


\item[-] Otherwise, there exists $a_2 \in \textit{Items}(e,\textit{pri})$, such that the rightmost gap-point of $a_1$ is before $\textit{cal}(\textit{put},a_2,\textit{pri})$ or $\textit{cal}(\textit{rm},a_2)$ in $e$. We can see that each gap-point of $a_2$ is after the rightmost gap-point of $a_1$.%, and thus, the right-most gap-point of $a_2$ is after the rightmost gap-point of $a_1$.
    By assumption, we know that $a_2$ does not $<_{\textit{pb}}$ to $a_1$.

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] If for each item $b \in \textit{Items}(e,\textit{pri})$, $a_2$ does not $<_{\textit{pb}}$ to $b$. Then we go to step $1$ and treat $a_2$ similarly as $a_1$.
    \item[-] Otherwise, there exists $a_3$ with priority $\textit{pri}$ such that $a_2 <_{\textit{pb}}^* a_3$.

    Since $l_{\textit{pri}}$ has FIFO property, it is easy to see that there is no cycle in $<_{\textit{pb}}$ order. It is safe to assume that $a_3$ is maximal in the sense of $<_{\textit{pb}}^*$. Or we can say, there does not exists $a_4$, such that $a_3 <_{\textit{pb}}^* a_4$.

    By assumption,we know that the rightmost gap-point of $a_3$ is after $\textit{cal}(\textit{put},a_2,\textit{pri})$ and $\textit{cal}(\textit{rm},a_2)$. Therefore, we can see that the rightmost gap-point of $a_3$ is after the rightmost gap-point of $a_3$. Then we go to step $1$ and treat $a_3$ similarly as $a_1$.
    \end{itemize}
\end{itemize}

Let $a^i$ be the $a_1$ in the $\textit{i-th}$ loop of our proof. It is not hard to see that, given $i<j$, the rightmost gap-point of $b_j$ is after the rightmost gap-point of $b_i$. Therefore, the loop finally stop at some $a^f$. $a^f$ satisfies the check of Step $1$. By Lemma \ref{lemma:maximal in pb and gap-point make a candidate of PQ1Equal}, this implies that $e \sqsubseteq \textit{MS}(\textit{PQ}_1^{=})$. This completes the proof of $\textit{if}$ direction. \qed
\end {proof}



According to the definition of $<_{\textit{ob}}^*$, if $a <_{\textit{pb}}^* b$, then there exists $a_1,\ldots,a_m$, such that $a <_{\textit{pb}} a_1 <_{\textit{pb}} \ldots <_{\textit{pb}} a_m <_{\textit{pb}} b$. The following lemma states that, the number of intermediate items $a_i$ is in fact bounded.

\OBOrderHasBoundedLength*

\begin {proof}

Our proof proceed as follows:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] ($<_{\textit{pb}}^A \cdot <_{\textit{pb}}^A$,$<_{\textit{pb}}^B \cdot <_{\textit{pb}}^B$ and $<_{\textit{pb}}^C \cdot <_{\textit{pb}}^C$): If $c_3 <_{\textit{pb}}^A c_2 <_{\textit{pb}}^A c_1$, then $\textit{put}(c_3,\_)$ happens before $\textit{put}(c_2,\_)$, and $\textit{put}(c_2,\_)$ happens before $\textit{put}(c_1,\_)$. Therefore, it is obvious that $\textit{put}(c_3,\_)$ happens before $\textit{put}(c_1,\_)$ and $c_3 <_{\textit{pb}}^A c_1$.

    Similarly, if $c_3 <_{\textit{pb}}^B c_2 <_{\textit{pb}}^B c_1$, then $c_3 <_{\textit{pb}}^B c_1$.

    If $c_3 <_{\textit{pb}}^C c_2 <_{\textit{pb}}^C c_1$: Since $c_2 <_{\textit{pb}}^C c_1$, $\textit{ret}(\textit{rm},c_2)$ is before $\textit{cal}(\textit{put},c_1,\_)$. Since $\textit{rm}(c_2)$ does not happen before $\textit{put}(c_2,\_)$, $\textit{cal}(\textit{put},c_2,\_)$ is before $\textit{ret}(\textit{rm},c_2)$. Since $c_3 <_{\textit{pb}}^C c_2$, $\textit{ret}(\textit{rm},c_3)$ is before $\textit{cal}(\textit{put},c_2,\_)$. Therefore, $\textit{ret}(\textit{rm},c_3)$ is before $\textit{cal}(\textit{put},c_1,\_)$, and $c_3 <_{\textit{pb}}^C c_1$.

    Therefore, when we meet successive $<_{\textit{pb}}^A$, it is safe to leave only the first and the last elements and ignore intermediate elements. Similar cases hold for $<_{\textit{pb}}^B$ and $<_{\textit{pb}}^C$.

\item[-] $<_{\textit{pb}}^A$ and $<_{\textit{pb}}^C$:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] ($<_{\textit{pb}}^A \cdot <_{\textit{pb}}^C$): If $c_3 <_{\textit{pb}}^A c_2 <_{\textit{pb}}^C c_1$. Since $c_2 <_{\textit{pb}}^C c_1$, $\textit{ret}(\textit{rm},c_2)$ is before $\textit{cal}(\textit{put},c_1,\_)$. Since $\textit{rm}(c_2)$ does not happen before $\textit{put}(c_2,\_)$, $\textit{cal}(\textit{put},c_2,\_)$ is before $\textit{ret}(\textit{rm},c_2)$. Since $c_3 <_{\textit{pb}}^A c_2$, $\textit{ret}(\textit{put},c_3)$ is before $\textit{cal}(\textit{put},c_2,\_)$. Therefore, $\textit{ret}(\textit{put},c_3)$ is before $\textit{cal}(\textit{put},c_1,\_)$, and $c_3 <_{\textit{pb}}^A c_1$.

    \item[-] ($<_{\textit{pb}}^C \cdot <_{\textit{pb}}^A$): If $c_3 <_{\textit{pb}}^C c_2 <_{\textit{pb}}^A c_1$. Since $c_2 <_{\textit{pb}}^A c_1$, $\textit{ret}(\textit{put},c_2)$ is before $\textit{cal}(\textit{put},c_1,\_)$. It is obvious that $\textit{cal}(\textit{put},c_2,\_)$ is before $\textit{ret}(\textit{put},c_2)$. Since $c_3 <_{\textit{pb}}^C c_2$, $\textit{ret}(\textit{rm},c_3)$ is before $\textit{cal}(\textit{put},c_2,\_)$. Therefore, $\textit{ret}(\textit{rm},c_3)$ is before $\textit{cal}(\textit{put},c_1,\_)$, and $c_3 <_{\textit{pb}}^C c_1$.

    %Since $c_2 <_{\textit{pb}}^A c_1$, $\textit{put}(c_2,\_)$ happens before $\textit{put}(c_1,\_)$. Since $c_3 <_{\textit{pb}}^C c_2$, $\textit{rm}(c_3)$ happens before $\textit{put}(c_2,\_)$. Therefore, $\textit{rm}(c_3)$ happens before $\textit{put}(c_1,\_)$, and $c_3 <_{\textit{pb}}^C c_1$.
    \end{itemize}

\item[-] $<_{\textit{pb}}^B$ and $<_{\textit{pb}}^C$:

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] ($<_{\textit{pb}}^B \cdot <_{\textit{pb}}^C$): If $c_3 <_{\textit{pb}}^B c_2 <_{\textit{pb}}^C c_1$. Since $c_2 <_{\textit{pb}}^C c_1$, $\textit{ret}(\textit{rm},c_2)$ is before $\textit{cal}(\textit{put},c_1,\_)$. It is obvious that $\textit{cal}(\textit{rm},c_2)$ is before $\textit{ret}(\textit{rm},c_2)$. Since $c_3 <_{\textit{pb}}^B c_2$, $\textit{ret}(\textit{rm},c_3)$ is before $\textit{cal}(\textit{rm},c_2)$. Therefore, $\textit{ret}(\textit{rm},c_3)$ is before $\textit{cal}(\textit{put},c_1,\_)$, and $c_3 <_{\textit{pb}}^C c_1$.

    \item[-] ($<_{\textit{pb}}^C \cdot <_{\textit{pb}}^B$): If $c_3 <_{\textit{pb}}^C c_2 <_{\textit{pb}}^B c_1$. Since $c_2 <_{\textit{pb}}^B c_1$, $\textit{ret}(\textit{rm},c_2)$ is before $\textit{cal}(\textit{rm},c_1)$. Since $\textit{rm}(c_2)$ does not happen before $\textit{put}(c_2,\_)$, $\textit{cal}(\textit{put},c_2,\_)$ is before $\textit{ret}(\textit{rm},c_2)$. Since $c_3 <_{\textit{pb}}^C c_2$, $\textit{ret}(\textit{rm},c_3)$ is before $\textit{cal}(\textit{put},c_2,\_)$. Therefore, $\textit{ret}(\textit{rm},c_3)$ is before $\textit{cal}(\textit{rm},c_1)$, and $c_3 <_{\textit{pb}}^B c_1$.
    \end{itemize}

\item[-]  ($<_{\textit{pb}}^A \cdot <_{\textit{pb}}^B \cdot <_{\textit{pb}}^A$): If $c_4 <_{\textit{pb}}^A c_3 <_{\textit{pb}}^B c_2 <_{\textit{pb}}^A c_1$:
    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] If $\textit{cal}(\textit{rm},c_2)$ is before $\textit{cal}(\textit{put},c_1,\_)$: Since $c_3 <_{\textit{pb}}^B c_2$, $\textit{ret}(\textit{rm},c_3)$ is before $\textit{cal}(\textit{rm},c_2)$. Then $\textit{ret}(\textit{rm},c_3)$ is before $\textit{cal}(\textit{put},c_1,\_)$, and $c_3 <_{\textit{pb}}^C c_1$. This implies that $c_4 <_{\textit{pb}}^A c_3 <_{\textit{pb}}^C c_1$. According to the fact for $<_{\textit{pb}}^A \cdot <_{\textit{pb}}^C$, we know that $c_4  <_{\textit{pb}}^A c_1$.

    \item[-] If $\textit{cal}(\textit{rm},c_2)$ is after $\textit{cal}(\textit{put},c_1,\_)$: Since $c_2 <_{\textit{pb}}^A c_1$, $\textit{ret}(\textit{put},c_2,\_)$ is before $\textit{cal}(\textit{put},c_1,\_)$. Since $c_3 <_{\textit{pb}}^B c_2$, $\textit{rm}(c_3)$ happens before $\textit{rm}(c_2)$, and then we know that $\textit{put}(c_2,\_)$ can not happen before $\textit{put}(c_3,\_)$. Since $\textit{put}(c_2,\_)$ does not happen before $\textit{put}(c_3,\_)$, $\textit{cal}(\textit{put},c_3,\_)$ is before $\textit{ret}(\textit{put},c_2,\_)$. Since $c_4 <_{\textit{pb}}^A c_3$, $\textit{ret}(\textit{put},c_4)$ is before $\textit{cal}(\textit{put},c_3,\_)$. Therefore, $\textit{ret}(\textit{put},c_4)$ is before $\textit{cal}(\textit{put},c_1,\_)$, and $c_4 <_{\textit{pb}}^A c_1$.
    \end{itemize}

\item[-]  ($<_{\textit{pb}}^B \cdot <_{\textit{pb}}^A \cdot <_{\textit{pb}}^B$): If $c_4 <_{\textit{pb}}^B c_3 <_{\textit{pb}}^A c_2 <_{\textit{pb}}^B c_1$: Since $c_2 <_{\textit{pb}}^B c_1$, $\textit{ret}(\textit{rm},c_2)$ is before $\textit{cal}(\textit{rm},c_1)$. Since $c_3 <_{\textit{pb}}^A c_2$, we can see that $\textit{put}(c_3,\_) <_{\textit{hb}} \textit{put}(c_2,\_)$. Since each single-priority execution has FIFO property, we know that $\textit{rm}(c_2)$ does not happen before $\textit{rm}(c_3)$, and thus, $\textit{cal}(\textit{rm},c_3)$ is before $\textit{ret}(\textit{rm},c_2)$. Since $c_4 <_{\textit{pb}}^B c_3$, $\textit{ret}(\textit{rm},c_4)$ is before $\textit{cal}(\textit{rm},c_3)$. Therefore, $\textit{ret}(\textit{rm},c_4)$ is before $\textit{cal}(\textit{rm},c_1)$, and $c_4 <_{\textit{pb}}^B c_1$.

\end{itemize}

Based on above results, given $a <_{\textit{pb}}^{b_1} a_1 <_{\textit{pb}} \ldots <_{\textit{pb}}^{b_m} a_m <_{\textit{pb}}^{b_{\textit{m+1}}} b$, where each $b_i$ is in $\{ A,B,C \}$, we can merge relations, until we got one of the following facts:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $a <_{\textit{pb}}^A b$, $a <_{\textit{pb}}^B b$ or $a <_{\textit{pb}}^C b$,

\item[-] $a <_{\textit{pb}}^A a_i <_{\textit{pb}}^B b$, or $a <_{\textit{pb}}^B a_i <_{\textit{pb}}^A b$, for some $i$,

\item[-] $a <_{\textit{pb}}^B a_i <_{\textit{pb}}^A a_j <_{\textit{pb}}^B b$, for some $i$ and $j$,
\end{itemize}

This completes the proof of this lemma. \qed
\end {proof}

There are many enumerations of method events of $a$, $b$ and $a_1$ that may makes $a <_{\textit{pb}}^* b$. The following lemma states that with the help of gap-points, the number of potential enumerations can be further reduced into only five.

\FiveEnmuerationisEnoughForPQOneEqual*

\begin {proof}

Let us prove by consider all the possible reason of $a <_{\textit{pb}}^* b$. According to Lemma \ref{lemma:ob order has bounded length}, we need to consider five reasons: Let $o$ be the right-most gap-point of $b$.

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Reason $1$, $a <_{\textit{pb}}^A b$:

    Since $a <_{\textit{pb}}^A b$, $\textit{put}(a,\_) <_{\textit{hb}} \textit{put}(b,\_)$. Since $o$ is after $\textit{cal}(\textit{put},b,\_)$, and thus, after $\textit{cal}(\textit{put},a,\_)$, we can see that $o$ is before $\textit{cal}(\textit{rm},b)$.

    Since single-priority execution must satisfy the FIFO property, $\textit{rm}(b)$ does not happen before $\textit{rm}(a)$, and thus, $\textit{cal}(\textit{rm},a)$ is before $\textit{ret}(\textit{rm},b)$. If $\textit{ret}(\textit{rm},a)$ is before $\textit{ret}(\textit{rm},b)$, since we already assume that there exists gap-point of $a$, this gap-point is also a gap-point of $b$, and is after $o$, which contradicts that $o$ is the rightmost gap-point of $b$. Therefore, $\textit{ret}(\textit{rm},a)$ is after $\textit{ret}(\textit{rm},b)$.

    According to above discussion, there are two possible enumeration of operations of $a$ and $b$, as shown in \figurename~\ref{fig:history enumeration 1 for PQ1Equal} and \figurename~\ref{fig:history enumeration 2 for PQ1Equal}. Here we explicitly draw the leftmost gap-point of $a$ as $o'$. Since the position of $\textit{ret}(\textit{put},b)$ does not influence the correctness, we can simply ignore it.

\item[-] Reason $2$, $a <_{\textit{pb}}^B b$:

    Since $a <_{\textit{pb}}^B b$, $\textit{ret}(\textit{rm},a)$ is before $\textit{cal}(\textit{rm},b)$. Since $o$ is after $\textit{cal}(\textit{rm},b)$, we can see that $\textit{ret}(\textit{rm},a)$ is before $o$. Then, we can see that $o$ is before $\textit{cal}(\textit{put},a,\_)$. This implies that $\textit{ret}(\textit{rm},a)$ is before $\textit{cal}(\textit{put},a,\_)$, and then $\textit{rm}(a) <_{\textit{hb}} \textit{put}(a)$, which is impossible. Therefore, we can safely ignore this reason.

\item[-] Reason $3$, $a <_{\textit{pb}}^C b$:

    Since $a <_{\textit{pb}}^B b$, $\textit{ret}(\textit{rm},a)$ is before $\textit{cal}(\textit{put},b,\_)$. Since $o$ is after $\textit{cal}(\textit{put},b)$, we can see that $\textit{ret}(\textit{rm},a)$ is before $o$. Then, we can see that $o$ is before $\textit{cal}(\textit{put},a,\_)$. This implies that $\textit{ret}(\textit{rm},a)$ is before $\textit{cal}(\textit{put},a,\_)$, and then $\textit{rm}(a) <_{\textit{hb}} \textit{put}(a)$, which is impossible. Therefore, we can safely ignore this reason.

\item[-] Reason $4$, $a <_{\textit{pb}}^A a_1 <_{\textit{pb}}^B b$:

    Since $a_1 <_{\textit{pb}}^B b$, $\textit{rm}(a_1) <_{\textit{hb}} \textit{rm}(b)$, and $\textit{ret}(\textit{rm},a_1)$ is before $\textit{cal}(\textit{rm},b)$. Since $\textit{rm}(a_1)$ does not happen before $\textit{put}(a_1)$, $\textit{cal}(\textit{put},a_1,\_)$ is before $\textit{ret}(\textit{rm},a_1)$. Since $a <_{\textit{pb}}^A a_1$, $\textit{ret}(\textit{put},a,\_)$ is before $\textit{cal}(\textit{put},a_1,\_)$. Therefore, $\textit{ret}(\textit{put},a,\_)$ is before $\textit{cal}(\textit{rm},b)$. Since $\textit{cal}(\textit{rm},b)$ is before $o$, we can see that $\textit{ret}(\textit{put},a,\_)$ is before $o$. Then, we can see that $o$ is before $\textit{cal}(\textit{rm},a)$.

    If $\textit{cal}(\textit{rm},a)$ is after $\textit{ret}(\textit{rm},b)$, then $e \vert_{ \{ a,a_1,b \} }$ violates the FIFO property. Therefore, $\textit{cal}(\textit{rm},a)$ is before $\textit{ret}(\textit{rm},b)$. Similarly as the case of reason $1$, we can see that $\textit{ret}(\textit{rm},b)$ is before $\textit{ret}(\textit{rm},a)$.

    According to above discussion, there are three possible enumeration of operations of $a$, $a_1$ and $b$, as shown in \figurename~\ref{fig:history enumeration 3 for PQ1Equal}, \figurename~\ref{fig:history enumeration 4 for PQ1Equal} and \figurename~\ref{fig:history enumeration 5 for PQ1Equal}. Here we explicitly draw the leftmost gap-point of $a$ as $o'$. Since the position of $\textit{ret}(\textit{put},a_1,\_)$ and $\textit{cal}(\textit{put},a,\_)$ do not influence the correctness, we can simply ignore it. We also ignore $\textit{cal}(\textit{put},b,\_)$ and $\textit{ret}(\textit{put},b)$, since the only requirements of them are (1) $\textit{rm}(b)$ does not happen before $\textit{put}(b)$ and (2) $\textit{cal}(\textit{put},b,\_)$ is before $o$.

\item[-] Reason $5$, $a <_{\textit{pb}}^B a_1 <_{\textit{pb}}^A b$:

    Since $a_1 <_{\textit{pb}}^A b$, $\textit{ret}(\textit{put},a_1)$ is before $\textit{call}(\textit{put},b,\_)$. Since $\textit{call}(\textit{put},b,\_)$ is before $o$, we can see that $\textit{ret}(\textit{put},a_1,\_)$ is before $o$.

    \begin{itemize}
    \setlength{\itemsep}{0.5pt}
    \item[-] If $o$ is before $\textit{cal}(\textit{rm},a)$: Then $o$ is obviously before $\textit{ret}(\textit{rm},a)$. Since $a <_{\textit{pb}}^B a_1$, $\textit{ret}(\textit{rm},a)$ is before $\textit{cal}(\textit{rm},a_1)$. Then we can see that, $o$ is before $\textit{cal}(\textit{rm},a_1)$, and remember that $a_1 <_{\textit{pb}}^A b$. Then we can goto the case of reason $1$ and treat $a_1$ as $a$. Therefore, we can safely ignore this.

    \item[-] If $o$ is before $\textit{cal}(\textit{put},a,\_)$: Since $\textit{rm}(a)$ does not happen before $\textit{put}(a,\_)$, we can see that $\textit{cal}(\textit{put},a,\_)$ is before $\textit{ret}(\textit{rm},a)$, and then $o$ is before $\textit{ret}(\textit{rm},a)$. Then similarly as above case, we can see that $o$ is before $\textit{cal}(\textit{rm},a_1)$, and $a_1 <_{\textit{pb}}^A b$. Then we can goto the case of reason $1$ and treat $a_1$ as $a$. Therefore, we can safely ignore this.
    \end{itemize}
\end{itemize}

This completes the proof of this lemma. \qed
\end {proof}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.4 \textwidth]{figures/PIC-HIS-PQ1Equal-1.pdf}
%\vspace{-10pt}
  \caption{The first possible enumeration.}
  \label{fig:history enumeration 1 for PQ1Equal}
\end{figure}


\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.4 \textwidth]{figures/PIC-HIS-PQ1Equal-2.pdf}
%\vspace{-10pt}
  \caption{The second possible enumeration.}
  \label{fig:history enumeration 2 for PQ1Equal}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.4 \textwidth]{figures/PIC-HIS-PQ1Equal-3.pdf}
%\vspace{-10pt}
  \caption{The third possible enumeration.}
  \label{fig:history enumeration 3 for PQ1Equal}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.4 \textwidth]{figures/PIC-HIS-PQ1Equal-4.pdf}
%\vspace{-10pt}
  \caption{The forth possible enumeration.}
  \label{fig:history enumeration 4 for PQ1Equal}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.4 \textwidth]{figures/PIC-HIS-PQ1Equal-5.pdf}
%\vspace{-10pt}
  \caption{The fifth possible enumeration.}
  \label{fig:history enumeration 5 for PQ1Equal}
\end{figure}


Let us begin to represent several witness automata that is used to capture the existence of a data-differentiated execution $e$, $e$ has a projection $e'$, $\textit{last}(e') = \textit{PQ}_1^{=}$, there exists items $a$ and $b$ with maximal priority in $e'$, $a <_{\textit{pb}} b$, and the rightmost gap-point of $b$ is before $\textit{cal}(\textit{put},a,\_)$ or $\textit{cal}(\textit{rm},a)$.

Given a data-differentiated execution $e$, two actions $\textit{act}_1$, $\textit{act}_2$ of maximal priority in $e$, and assume that $\textit{act}_1$ is before $\textit{act}_2$ in $e$.
we say that $\textit{act}_1$, $\textit{act}_2$ is covered by items $d_1,\ldots,d_m$ in $e$, if the priorities of $d_1,\ldots,d_m$ is smaller than that of $\textit{act}_1$ and $\textit{act}_2$, and

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\textit{ret}(\textit{put},d_m,\_)$ is before $\textit{act}_1$,

\item[-] For each $i < 1 \leq m$,$\textit{put}(d_{\textit{i-1}},\_)$ happens before $\textit{rm}(d_i)$,

\item[-] $\textit{act}_2$ is before $\textit{cal}(\textit{rm},d_1)$.
\end{itemize}

According to Lemma \ref{lemma:PQ1Equal as pb order and gap-point}, Lemma \ref{lemma:ob order has bounded length} and Lemma \ref{lemma:five enumeration is enough for PQ1Equal}, it is not hard to prove that, given a data-differentiated execution $e$ with $\textit{last}(e) = \textit{PQ}_1^{=}$, $e$ does not linearizable with respect to $\textit{MS}(\textit{PQ}_1^{=})$, if and only if, one of enumerations holds in $e$ (permit renaming), while $\textit{cal}(\textit{rm},a)$ and $\textit{ret}(\textit{rm},b)$ is covered by some $d_1,\ldots,d_m$, $\textit{cal}(\textit{rm},b)$ is before $\textit{ret}(\textit{put},d_m,\_)$, and $\textit{cal}(\textit{rm},d_1)$ is before $\textit{ret}(\textit{rm},a)$. We say that such $d_1,\ldots,d_m$ constitute the rightmost gap of $b$.


An automaton $\mathcal{A}_{\textit{l-eq}}^1$ is given in \figurename~\ref{fig:automata for first enumeration of PQ1Equal}, and it is constructed for the first enumeration in \figurename~\ref{fig:history enumeration 1 for PQ1Equal}. Here we rename the items that covers $\textit{cal}(\textit{rm},a)$ and $\textit{ret}(\textit{rm},b)$ into $d$, and rename the remanning items into $e$. In this figure, $c = \textit{cal}(\textit{put},e,\textit{anyPri}),\textit{ret}(\textit{put},e)$, $\textit{cal}(\textit{rm},e), \textit{ret}(\textit{rm},e)$, $c_1 = c + \textit{cal}(\textit{put},d,\textit{les}_p)$, $c_2 = c_1 + \textit{ret}(\textit{put},b)$, $c_3 = c_2 + \textit{ret}(\textit{rm},d)$, $c_4 = c + \textit{ret}(\textit{put},b) + \textit{ret}(\textit{rm},d)$.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8 \textwidth]{figures/PIC_AUTO_PQ1Equ-1.pdf}
%\vspace{-10pt}
  \caption{Automaton $\mathcal{A}_{\textit{l-eq}}^1$}
  \label{fig:automata for first enumeration of PQ1Equal}
\end{figure}


An automaton $\mathcal{A}_{\textit{l-eq}}^2$ is given in \figurename~\ref{fig:automata for second enumeration of PQ1Equal}, and it is constructed for the second enumeration in \figurename~\ref{fig:history enumeration 2 for PQ1Equal}. In \figurename~\ref{fig:automata for second enumeration of PQ1Equal}, $c_1$, $c_2$, $c_3$ and $c_4$ is same as that in \figurename~\ref{fig:automata for first enumeration of PQ1Equal}.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8 \textwidth]{figures/PIC_AUTO_PQ1Equ-2.pdf}
%\vspace{-10pt}
  \caption{Automaton $\mathcal{A}_{\textit{l-eq}}^2$}
  \label{fig:automata for second enumeration of PQ1Equal}
\end{figure}

For the third enumeration in \figurename~\ref{fig:history enumeration 3 for PQ1Equal}. Since we want to ensure that $a$ and $b$ are putted only once, we need to explicitly record the positions of $\textit{cal}(\textit{put},a,p)$ and $\textit{cal}(\textit{put},b,p)$. Since the positions of $\textit{cal}(\textit{put},a,p)$ and $\textit{cal}(\textit{put},b,p)$ are not fixed, there are finite possible cases to consider, as shown below:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $\textit{cal}(\textit{put},b,p)$ is after $\textit{cal}(\textit{rm},b)$ and before $\textit{cal}(\textit{rm},a)$: There are two possible positions of $\textit{cal}(\textit{put},a,p)$: (1) before $\textit{cal}(\textit{rm},a_1)$, and (2) after $\textit{cal}(\textit{rm},a_1)$, and before $\textit{ret}(\textit{put},a)$.

\item[-] If $\textit{cal}(\textit{put},b,p)$ is after $\textit{ret}(\textit{rm},a_1)$ and before $\textit{cal}(\textit{rm},b)$: same as above case.

\item[-] If $\textit{cal}(\textit{put},b,p)$ is after $\textit{cal}(\textit{put},a_1,\_)$ and before $\textit{ret}(\textit{rm},a_1)$: same as above case.

\item[-] If $\textit{cal}(\textit{put},b,p)$ is after $\textit{ret}(\textit{put},a)$ and before $\textit{cal}(\textit{put},a_1,p)$: same as above case.

\item[-] If $\textit{cal}(\textit{put},b,p)$ is after $\textit{cal}(\textit{rm},a_1)$ and before $\textit{ret}(\textit{put},a)$: There are three possible positions of $\textit{cal}(\textit{put},a,p)$: (1) after $\textit{cal}(\textit{put},b,p)$ and before $\textit{ret}(\textit{put},a)$, (2) after $\textit{cal}(\textit{rm},a_1)$ and before $\textit{cal}(\textit{put},b,p)$, and (3) before $\textit{call}(\textit{rm},a_1)$.

\item[-] If $\textit{cal}(\textit{put},b,p)$ is before $\textit{cal}(\textit{rm},a_1)$: There are three possible positions of $\textit{cal}(\textit{put},a,p)$: (1) after $\textit{cal}(\textit{rm},a_1)$ and before $\textit{ret}(\textit{put},a)$, (2) after $\textit{cal}(\textit{put},b,p)$ and before $\textit{cal}(\textit{rm},a_1)$, and (3) before $\textit{cal}(\textit{put},b,p)$.
\end{itemize}

Therefore, there are fourteen possible cases that satisfy the third enumeration in \figurename~\ref{fig:history enumeration 3 for PQ1Equal}. For each case, we construct an finite automaton. Let $\textit{Auts}_{\textit{1-eq}}^{3}$ be the set of finite automata that is constructed for above fourteen cases. For example, for the case $\textit{ca}_1$ when $\textit{cal}(\textit{put},a,p)$ is before $\textit{cal}(\textit{rm},a_1)$, $\textit{cal}(\textit{put},b,p)$ is after $\textit{ret}(\textit{rm},a_1)$, and $\textit{cal}(\textit{put},b,p)$ is before $\textit{cal}(\textit{rm},b)$, we construct a finite automaton $\mathcal{A}_{\textit{l-eq}}^{\textit{3-1}}$ in \figurename~\ref{fig:automata for ca1 of third enumeration of Rpr2}. In \figurename~\ref{fig:automata for ca1 of third enumeration of Rpr2}, let $c$ and $c_1 = c + \textit{cal}(\textit{put},d,\textit{les}_p)$ the same as that in \figurename~\ref{fig:automata for first enumeration of PQ1Equal}. Let $c_2 = c_1 + \textit{ret}(\textit{put},a_1)$, $c_3 = c_2 + \textit{ret}(\textit{put},b)$, $c_4 = c_3 + \textit{ret}(\textit{rm},d)$, and $c_5 = c + \textit{ret}(\textit{put},b) + \textit{ret}(\textit{put},a_1) + \textit{ret}(\textit{rm},d)$. The other witness automata in $\textit{Auts}_{\textit{1-eq}}^{3}$ can be similarly constructed.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8 \textwidth]{figures/PIC_AUTO_PQ1Equ-3-1.pdf}
%\vspace{-10pt}
  \caption{Automaton $\mathcal{A}_{\textit{l-eq}}^{\textit{3-1}}$}
  \label{fig:automata for ca1 of third enumeration of Rpr2}
\end{figure}

Similarly, we construct sets $\textit{Auts}_{\textit{1-eq}}^{4}$ and $\textit{Auts}_{\textit{1-eq}}^{5}$ of witness automata for the forth enumeration in \figurename~\ref{fig:history enumeration 4 for PQ1Equal} and the fifth enumeration in \figurename~\ref{fig:history enumeration 5 for PQ1Equal}, respectively.

Let $\textit{Auts}_{\textit{1-eq}} = \{ \mathcal{A}_{\textit{l-eq}}^1, \mathcal{A}_{\textit{l-eq}}^2 \} \cup \textit{Auts}_{\textit{1-eq}}^{3} \cup \textit{Auts}_{\textit{1-eq}}^{4} \cup \textit{Auts}_{\textit{1-eq}}^{5}$. The following lemma states that $\textit{PQ}_1^{=}$ is co-regular.


\PQOneEqualIsCoRegular*

\begin {proof}

We need to prove that, given a data-independence implementation $\mathcal{I}$, $\textit{Auts}_{\textit{1-eq}} \cap \mathcal{I} = \emptyset$ if and only if $\exists e \in \mathcal{I}_{\neq},e' \in \textit{proj}(e), last(e')=\textit{PQ}_1^{=} \wedge e$ does not linearizable w.r.t. $\textit{MS}(\textit{PQ}_1^{=})$.

By Lemma \ref{lemma:PQ1Equal as pb order and gap-point}, we need to prove the following fact:

\noindent {\bf $\textit{fact}_1$}: Given a data-independence implementation $\mathcal{I}$, $\textit{Auts}_{\textit{1-eq}} \cap \mathcal{I} = \emptyset$ if and only if $\exists e \in \mathcal{I}_{\neq},e' \in \textit{proj}(e), last(e')=\textit{PQ}_1^{=}$, $a$ and $b$ are two items with maximal priority in $e'$, $a <_{\textit{pb}}^* b$ in $e'$, and the rightmost gap-point of $b$ is before $\textit{cal}(\textit{put},a,\_)$ or $\textit{cal}(\textit{rm},a)$ in $e'$.


\noindent The $\textit{only if}$ direction: Assume that $e_1 \in \mathcal{I}$ is accepted by some witness automata in $\textit{Auts}_{\textit{1-eq}}$. By data-independence, there exists data-differentiated execution $e_2 \in \mathcal{I}$ and a renaming function $r$, such that $e_1=r(e_2)$. Since $e_1$ is accepted by some witness automata in  $\textit{Auts}_{\textit{1-eq}}$, let $x$, $y$ and $z$ (if exists) be the items that are renamed into $b$, $a$ and $a_1$ (if exists) by $r$, respectively, and let $d_1,\ldots,d_m$ be the items that are renamed into $d$ by $r$.

let $e'' = e_2 \vert_{ \{ x,y,z,d_1,\ldots,d_m \} }$. It is obvious that $\textit{last}(e'') = \textit{PQ}_1^{=}$. According to our construction of automata in $\textit{Auts}_{\textit{1-eq}}$, it is not hard to see that $x$ and $y$ has maximal priority in $h_2$, $y <_{\textit{pb}}^* x$, and the rightmost gap-point of $x$ is before $\textit{cal}(\textit{put},y,\_)$ or $\textit{cal}(\textit{rm},y)$ in $e''$.

\noindent The $\textit{if}$ direction: Assume that there exists $e \in \mathcal{I}_{\neq},e' \in \textit{proj}(e)$, such that $last(e')=\textit{PQ}_1^{=}$, $a'$ and $b'$ are two items with maximal priority in $e'$, $a' <_{\textit{pb}}^* b'$ in $e'$, and the rightmost gap-point of $b'$ is before $\textit{cal}(\textit{put},a',\_)$ or $\textit{cal}(\textit{rm},a')$ in $e'$. By data-independence, we can obtain execution $e_1$ as follows: (1) rename $a'$ and $b'$ into $a$ and $b$, respectively, (2) for the items $d_1,\ldots,d_m$ that constitute the rightmost gap of $b'$, we rename them into $d$, (3) if $a' <_{\textit{pb}}^A a'_1 <_{\textit{pb}}^B b$, we rename $a'_1$ into $a_1$, and (4) rename the other items into $e$. It is easy to see that $\textit{last}(e_1) = \textit{PQ}_1^{=}$, $a$ and $b$ has maximal priority in $e_1$, $a <_{\textit{pb}}^* b$ in $e_1$, and the rightmost gap-point of $b$ is before $\textit{cal}(\textit{put},a,\_)$ or $\textit{cal}(\textit{rm},a)$ in $e_1$. By Lemma \ref{lemma:five enumeration is enough for PQ1Equal}, there are five possible enumeration of operations of $a$, $b$, $a_1$ (if exists). Then


\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $a <_{\textit{pb}}^* b$ because of the first enumeration, it is easy to see that $h_1$ is accepted by $\mathcal{A}_{\textit{l-eq}}^1$.

\item[-] If $a <_{\textit{pb}}^* b$ because of the second enumeration, it is easy to see that $h_1$ is accepted by $\mathcal{A}_{\textit{l-eq}}^2$.

\item[-] If $a <_{\textit{pb}}^* b$ because of the third enumeration, it is easy to see that $h_1$ is accepted by some witness automaton in $\textit{Auts}_{\textit{1-eq}}^{3}$.

\item[-] If $a <_{\textit{pb}}^* b$ because of the forth enumeration, it is easy to see that $h_1$ is accepted by some witness automaton in $\textit{Auts}_{\textit{1-eq}}^{4}$.

\item[-] If $a <_{\textit{pb}}^* b$ because of the fifth enumeration, it is easy to see that $h_1$ is accepted by some witness automaton in $\textit{Auts}_{\textit{1-eq}}^{5}$.
\end{itemize}

This completes the proof of this lemma. \qed
\end {proof}













































\subsection{Co-Regular of $R_{\textit{pr3}}$}
\label{subsec:co-regular of Rpr3}


\begin{restatable}{lemma}{Rpr3IsAlwaysCoRegular}
\label{lemma:Rpr3 is always co-regular}
Given a data-differentiated history $h$, if $\textit{last}(h) = R_{\textit{pr3}}$, then $h \sqsubseteq \textit{MR}_{\textit{pr3}}$.
\end{restatable}

\begin {proof}

Since $\textit{last}(h) = R_{\textit{pr3}}$, there exists item $x$ with $\textit{pri}_x$ in $h$, such that $h \vert_{ \{ x \}} = \textit{put}(x,\textit{pri}_x)$, and $\textit{pri}_x$ is larger than any priority of $h$.

For each operation, we locate its linearization point just after its call action. In such way we obtain a sequence $l$ of operations, and it is easy to see that $h \sqsubseteq l$. It is obvious that $l$ contains $\textit{put}(x,\textit{pri})$, and then $l \in \textit{MR}_{\textit{pr3}}$. This completes the proof of this lemma. \qed
\end {proof}



\subsection{Co-Regular of $R_{\textit{pr4}}$}
\label{subsec:co-regular of Rpr4}

\begin{restatable}{lemma}{Rp4AsHappenBefore}
\label{lemma:Rpr4 as happen before}
Given a data-differentiated history $h$. There exists $h' \in \textit{proj}(h)$, such that $\textit{last}(h') = R_{\textit{pr4}}$, and $h'$ does not linearizable to $\textit{MR}_{\textit{pr4}}$, if and only if there exists $h'' \in \textit{proj}(h)$, $\textit{last}(h'') = R_{\textit{pr4}}$, $x$ and $y$ has maximal priority in $h''$, $x$ has unmatched $\textit{put}$, $y$ has matched $\textit{put}$ and $\textit{rm}$, and $\textit{put}(x,\_) <_{\textit{hb}} \textit{put}(y,\_)$.
\end{restatable}

\begin {proof}

To prove the $\textit{if}$ direction, let $h_1 = h \vert_{ \{ x,y \} }$. It is easy to see that $\textit{last}(h') = R_{\textit{pr4}}$ and $h_1$ does not linearizable to $\textit{MR}_{\textit{pr4}}$.

To prove the $\textit{only if}$ direction, we prove its contrapositive. Assume that for each $h'' \in \textit{proj}(h)$, such that $\textit{last}(h'') = R_{\textit{pr4}}$, for each $x$ and $y$ has maximal priority in $h''$, if $x$ has unmatched $\textit{put}$, $y$ has matched $\textit{put}$ and $\textit{rm}$, then $\textit{put}(x,\_)$ does not happen before $\textit{put}(y,\_)$. We need to prove that, for each $h' \in \textit{proj}(h)$, if $\textit{last}(h') = R_{\textit{pr4}}$, then $h' \sqsubseteq \textit{MR}_{\textit{pr4}}$.

Given such $h'$, let $x_1,\ldots,x_m$ be the set of items with maximal priority and has unmatched $\textit{put}$ operations, let $y_1,\ldots,y_n$ be the set of items with maximal priority and has matched $\textit{put}$ and $\textit{rm}$ operations. It is easy to see that, for each $x_i$ and $y_j$, $\textit{cal}(\textit{put},y_j)$ is before $\textit{ret}(\textit{put},x_i,\_)$. Then we locate the linearization points of $h'$ as follows:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] For each $x_i$, locate the linearization point of $\textit{put}(x_i,\_)$ just before its return action.

\item[-] For each $y_j$, locate the lineariztion point of $\textit{put}(y_j,\_)$ jest after its call action.

\item[-] For other operations, locate their linearization points at an arbitrary location after its call action and before its return action.
\end{itemize}

Let $l$ be the sequence of linearization points. It is easy to see that $h \sqsubseteq l$, and $l \in \textit{MR}_{\textit{pr4}}$. Here the $\textit{itm}$ in $R_{\textit{pr4}}$ is chosen to be $\textit{ret}(\textit{put},x_{\textit{ind}},\_)$, where the return action of $x_{\textit{ind}}$ is later than return actions of other $x_i$. This completes the proof of this lemma. \qed
\end {proof}


\begin{restatable}{lemma}{Rpr4IsAlwaysCoRegular}
\label{lemma:Rpr4 is always co-regular}
Given a data-differentiated history $h$, if $\textit{last}(h) = R_{\textit{pr4}}$, then $h \sqsubseteq \textit{MR}_{\textit{pr4}}$.
\end{restatable}

\begin {proof}

According to Lemma \ref{lemma:Rpr4 as happen before}, if $\textit{last}(h) = R_{\textit{pr4}}$ and $h$ does not linearizable to $\textit{MR}_{\textit{pr4}}$, then there exists $x$ and $y$ with maximal priority in $h$, $x$ has unmatched $\textit{put}$, $y$ has matched $\textit{put}$ and $\textit{rm}$, and $\textit{put}(x,\_) <_{\textit{hb}} \textit{put}(y,\_)$. Let $h_1 = h \vert_{ \{ x,y \} }$. It is obvious that $\textit{transToQueue}(h_1)$ does not linearizable to queue. This contradicts the assumption that every single-priority history can be ``linearizable to queue'', and thus, we can safely ignore this case. \qed
\end {proof}




\subsection{Co-Regular of $R_{\textit{pr5}}$}
\label{subsec:co-regular of Rpr5}

$R_{\textit{pr5}} \equiv (u \cdot v \in \textit{PQueue}) \wedge (\textit{matched}(u,\textit{put},\textit{rm}) ) \Rightarrow (u \cdot \textit{rmEmpty} \cdot v \in \textit{PQueue})$

Similar as the notion of gap in \cite{Bouajjani:2015}, we propose the notion of gap of $\textit{em}(\textit{empty})$ operations.

\begin{definition}[gap for $\textit{em}(\textit{empty})$ operations]\label{def:gap for rmEmpty operations}

Let $h$ be a data-differentiated history and $o = \textit{rm}(\textit{empty})$ of $h$. We say that $h$ has a gap on operation $o$, if there is a partition of the operations of $h$ into $L$ and $R$ satisfying:
\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $L$ has matched $\textit{put}$ and $\textit{rm}$ operations.

\item[-] no operation of $R$ happens before an operation of $L$ or $o$.

\item[-] $o$ does not happen before operations of $L$
\end{itemize}
\end{definition}

Compared to the gap on $\textit{put}$ and $\textit{rm}$ operations, here we do not consider the priority of operations in $L$ or $R$.



\begin{restatable}{lemma}{GapEqualsLinforRpr5}
\label{lemma:Gap Equals Lin for Rpr5}
A data-differentiated history $h$ has a projection $h'$, such that $\textit{last}(h') = R_{\textit{pr5}}$ and $h'$ does not linearizable to $\textit{MR}_{\textit{pr5}}$, if and only if there exists a projection $h''$ of $h$, such that $\textit{last}(h'') = R_{\textit{pr5}}$, there exists $o = \textit{rm}(\textit{empty})$ in $h''$, and there is no gap of $o$ in $h''$.
\end{restatable}

\begin {proof}

Let us prove the $\textit{only if}$ direction by contradiction. Assume that there exists such $h'$, and for each $\textit{rm}(\textit{empty})$ in $h'$, there is a gap of $o$ in $h''$. Since $\textit{last}(h') = R_{\textit{pr5}}$, there is exists at least $\textit{rm}(\textit{empty})$ operation in $h$, and let $o$ be arbitrary one of them. Since there is a gap of $o$ in $h$, let $L$ and $R$ be the sets of the gap. Let $u$ be a sequence of operations of $L$, and $u$ is generated from $h$ by locating linearization points of each operation in $L$ just after its call action. Let $v$ be a sequence of operations of $R$, and $v$ is generated from $h$ by locating linearization points of each operation in $R$ just before its return action. It is easy to see that $h \sqsubseteq l = u \cdot o \cdot v$, and $l \in \textit{MR}_{\textit{pr5}}$. This contradicts that $h'$ does not linearizable to $\textit{MR}_{\textit{pr5}}$.

To prove the $\textit{if}$ direction, let $h_1$ be a history generate from $h''$ by discarding all other $\textit{rm}(\textit{Empty})$ operations. By assumption, it is obvious that there is no gap of $o$ in $h_1$. Assume by contradiction that there exists $l'$, such that $h_1 \sqsubseteq l' \in \textit{MR}_{\textit{pr5}}$. It is easy to see that $l' = u' \cdot o \cdot v'$, such that $u'$ contains matched $\textit{put}$ and $\textit{rm}$ operations. Let $L$ be the set of operations of $u'$, and $R$ be the set of operations in $v'$. Since $h_1 \sqsubseteq l'$, it is easy to see that $L$ and $R$ is a gap of $o$ in $h_1$, contradicts that there is no gap of $o$ in $h_1$. \qed
\end {proof}

Similar as the notion of gap in \cite{Bouajjani:2015}, we propose the notion left-right constraint of $\textit{rm}(\textit{empty})$ operation.

\begin{definition}[left-right constraint for $\textit{rm}(\textit{empty})$ operation]\label{def:left-right constraint for rmEmpty operation}
Given a data-differentiated history $h$, and $o = \textit{rm}(\textit{empty})$ of $h$. The left-right constraint of $o$ is the graph $G$ where:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] the nodes are the items of $h$ or $o$, to which we add a node,

\item[-] there is an edge from item $d_1$ to $o$, if $\textit{put}(d_1,\_)$ happens before $o$,

\item[-] there is an edge from $o$ to item $d_1$, if $o$ happens before $\textit{rm}(d_1)$ or $\textit{rm}(d_1)$ does not exists in $h$,

\item[-] there is an edge from item $d_1$ to item $d_2$, if $\textit{put}(d_1,\_)$ happens before $\textit{rm}(d_2,\_)$.
\end{itemize}
\end{definition}

Compared to the left-right constraint of $\textit{put}$ and $\textit{rm}$ operations, here we do not consider the priority. We also do not consider other $\textit{rm}(\textit{empty})$ operations in $h$.

Given a data-differentiated history $h$ and $o = \textit{rm}(\textit{empty})$ of $h$. Let $\textit{LMSet}_1(h,o) = \{ \textit{op} \vert$ $\textit{op}$ is an operation of some item, either $\textit{op}$ happens before $o$ in $h$, or there is an operation $\textit{op}'$ with the same item of $\textit{op}$, such that $\textit{op}'$ happens before $o$ in $h$ $\}$. For each $i \geq 1$, let $\textit{LMSet}_{\textit{i+1}}(h,o) = \{ \textit{op} \vert$ $\textit{op}$ is an operation of some item, $\textit{op}$ is not an operation of items in $\textit{LMSet}_k(h,o)$ for each $k \leq i$, either $\textit{op}$ happens before some operation $o' \in \textit{LMSet}_i(h,o)$ in $h$, or there is an operation $\textit{op}''$ with the same item of $o$ and $\textit{op}''$ happens before some operation $o' \in \textit{LMSet}_i(h,o)$ in $h$ $\}$. We can see that $\textit{LMSet}_i(h,o) \cap \textit{LMSet}_j(h,o) = \emptyset$ for any $i \neq j$. Let $\textit{LMSet}(h,o) = \textit{LMSet}_1(h,o) \cup \textit{LMSet}_2(h,o) \cup \ldots$.


\begin{restatable}{lemma}{RmEmptyDoesNotHappenBeforeLMSetForRpr5}
\label{lemma:RmEmpty does not happen before LMSet for Rpr5}
Given a data-differentiated history $h$ and $o = \textit{rm}(\textit{empty})$ of $h$. Let $G$ be the graph representing the left-right constraint of $o$. Assume that $G$ has no cycle going through $o$. Then, $o$ does not happen before any operation in $\textit{LMSet}(h,o)$.
\end{restatable}

This Lemma can be similarly proved as Lemma \ref{lemma:Rmx does not happen before LMSet for Rpr1}.


\begin{restatable}{lemma}{LMSetHasMatchedPutandRmOperationsForRpr5}
\label{lemma:LMSet has matched put and rm operations for Rpr5}
Given a data-differentiated history $h$ and $o = \textit{rm}(\textit{empty})$ of $h$. Let $G$ be the graph representing the left-right constraint of $o$. Assume that $G$ has no cycle going through $o$. Then, $\textit{LMSet}(h,o)$ contains only matched $\textit{put}$ and $\textit{rm}$ operations.
\end{restatable}

This Lemma can be similarly proved as Lemma \ref{lemma:LMSet has matched put and rm operations}.


\begin{restatable}{lemma}{GapEqualsConstraintforRpr5}
\label{lemma:Gap Equals Constraint for Rpr5}
Given a data-differentiated history $h$ and $o = \textit{rm}(\textit{empty})$ of $h$. Let $G$ be the graph representing the left-right constraint of $o$. There is a gap on $o$, if and only if $G$ has no cycle going through $o$.
\end{restatable}

\begin {proof}

To prove the $\textit{only if}$ direction, assume that there is a gap on $o$, and let it be $L$ and $R$. Assume by contradiction that, there is a cycle $d_1 \rightarrow d_2 \rightarrow \ldots \rightarrow d_m \rightarrow o \rightarrow d_1$ in $G$. Since $o \rightarrow d_1$, either $o$ happens before $\textit{rm}(d_1)$ or $\textit{rm}(d_1)$ does not exists in $h$. Since $L$ contains matched $\textit{put}$ and $\textit{rm}$ operations, it is easy to see that operations of $d_1$ is in $R$. Since $d_1 \rightarrow d_2$, we can see that $\textit{put}(d_1,\_)$ happens before $\textit{rm}(d_2,\_)$. Since operations of $d_1$ is in $R$ and $L$ contains matched $\textit{put}$ and $\textit{rm}$ operations, we can see that operations of $d_2$ is in $R$. Similarly, we can prove that operations of $d_3,\ldots,d_m$ is in $R$. Since $d_m \rightarrow o$, $\textit{put}(d_m,\_)$ happens before $o$, and $\textit{put}(d_m,\_) \in L$. This contradicts that operations of $d_m$ is in $R$. This completes the proof of the $\textit{only if}$ direction.

To prove the $\textit{if}$ direction, assume that $G$ has no cycle going through $o$. Let $O_h$ be the set of operations of $h$. Let $O_L = \textit{LMSet}(h,o)$, $O_R = O_h \setminus O_L$.

By Lemma \ref{lemma:LMSet has matched put and rm operations for Rpr5}, we can see that $O_L = \textit{LMSet}(h,o)$ contains only matched $\textit{put}$ and $\textit{rm}$ operations. It remains to prove that $L$ and $R$ is a gap of $o$. We prove this by showing that all the following cases are impossible:

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Case $1$: Some operation $o_r \in R$ happens before $o$. Then we know that $o_r \in \textit{LMSet}(h,o)$, which contradicts that $o_r \in R$.

\item[-] Case $2$: Some operation $o_r \in R$ happens before some operation $o_l$. Then we know that $o_r \in \textit{LMSet}(h,o)$, which contradicts that $o_r \in R$.

\item[-] Case $4$: $o$ happens before some $o_l \in \textit{LMSet}(h,o) = L$. By Lemma \ref{lemma:RmEmpty does not happen before LMSet for Rpr5}, we know that this is impossible.
\end{itemize}

This completes the proof of the $\textit{if}$ direction.

\qed
\end {proof}

Let us begin to represent an automaton that is used for capture the case that, in a sub-history $h'$ of a history $h$, $\textit{last}(h')=R_{\textit{pr5}}$, $h'$ does not linearizable to $\textit{MR}_{\textit{pr5}}$, and the reason is that there is no gap on a $\textit{rm}(\textit{empty})$ operation in $h'$. The automaton is $\mathcal{A}_{\textit{Rpr5}}$, which is given in \figurename~\ref{fig:automata for Rpr5}. In \figurename~\ref{fig:automata for Rpr5}, let $c = \textit{cal}(\textit{put},d,\textit{anyPri}),\textit{ret}(\textit{put},d), \textit{cal}(\textit{rm},d), \textit{ret}(\textit{rm},d)$, $c_1 = c + \textit{cal}(\textit{put},b,\textit{anPri})$, $c_2 = c_1 + \textit{ret}(\textit{rm},b)$, and $c_3 = c + \textit{ret}(\textit{rm},b)$.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8 \textwidth]{PIC_AUTO_Rpr5.pdf}
%\vspace{-10pt}
  \caption{Automaton $\mathcal{A}_{\textit{Rpr5}}$}
  \label{fig:automata for Rpr5}
\end{figure}

Given a data-differentiated history $h$, we say that $o = \textit{rm}(\textit{empty})$ in $h$ is covered by items $d_1,\ldots,d_m$ in $h$, if

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\textit{put}(d_m,\_)$ happens before $o$,

\item[-] For each $i < 1 \leq m$,$\textit{put}(d_{\textit{i-1}},\_)$ happens before $\textit{rm}(d_i)$,

\item[-] $o$ happens before $\textit{rm}(d_1)$, or $\textit{rm}(d_1)$ does not exists in $h$
\end{itemize}

According to the definition of left-right constraint for $o$, in a data-differentiated history $h$, there is a cycle going through $o$, if and only if there exists items $d_1,\ldots,d_m$, such that $o$ is covered by $d_1,\ldots,d_m$.


\begin{restatable}{lemma}{Rpr5IsCoRegular}
\label{lemma:Rpr1 5s co-regular}
$R_{\textit{pr5}}$ is co-regular.
\end{restatable}

\begin {proof}

We need to prove that:

\noindent {\bf $\textit{fact}_1$}: Given a data-independent implementation $\mathcal{I}$, $\mathcal{A}_{\textit{Rpr5}} \cap \mathcal{I} \neq \emptyset$, if and only if there exists data-differentiated history $h \in \mathcal{I}$, $h'$ is a projection of $h$, $\textit{last}(h') = R_{\textit{pr5}}$ and $h$ does not linearizable to $\textit{MR}_{\textit{pr5}}$.

By Lemma \ref{lemma:Gap Equals Lin for Rpr5} and Lemma \ref{lemma:Gap Equals Constraint for Rpr5}, $\textit{fact}_1$ is equivalent to $\textit{fact}_2$:

\noindent {\bf $\textit{fact}_2$}: Given a data-independent implementation $\mathcal{I}$, $\mathcal{A}_{\textit{Rpr5}} \cap \mathcal{I} \neq \emptyset$, if and only if there exists data-differentiated history $h \in \mathcal{I}$, $h''$ is a projection of $h$, such that $\textit{last}(h'') = R_{\textit{pr5}}$, $o = \textit{rm}(\textit{empty})$ is in $h''$, and $o$ is covered by some items $d_1,\ldots,d_m$ in $h''$.


\noindent The $\textit{only if}$ direction: Assume that $h_1 \in \mathcal{I}$ is accepted by $\mathcal{A}_{\textit{Rpr5}}$. By data-independence, there exists data-differentiated sequence $h_2 \in \mathcal{I}$ and a renaming function $r$, such that $h_1=r(h_2)$. Let $d_1,\ldots,d_m$ be the items in $h_2$ such that $r(d_i)=d$ for each $1 \leq i \leq m$. Let $h'' = h_2 \vert_{ \{ o, d_0, d_1, \ldots, d_m \} }$. It is obvious that $\textit{last}(h'') = R_{\textit{pr5}}$. It is easy to see that $o$ is covered by $d_1,\ldots,d_m$.

\noindent The $\textit{if}$ direction: Assume that there exists such $h$, $h''$, $o$ and $d_1,\ldots,d_m$. Then, let $h_1$ be obtained from $h$ by renaming $d_1,\ldots,d_m$ into $b$ and renaming other items into $d$. We can prove that $h_1$ is accepted by $\mathcal{A}_{\textit{Rpr5}}$.

This completes the proof of this lemma. \qed
\end {proof}




\section{Relate Queue and Stack with Priority Queue}
\label{sec:relate queue and stack with priority queue}




\subsection{Relate Queue with Priority Queue}
\label{subsec:relate queue with priority queue}

Given a history $h_q$ of queue operations, let $\textit{UniPriTrans}(h_q)$ be a history of priority queue, which is generated as follows: transform each $\textit{call}(\textit{enq},a)$, $\textit{ret}(\textit{enq},a)$, $\textit{call}(\textit{deq},a)$ and $\textit{ret}(\textit{deq},a)$ of $h_q$ into $\textit{call}(\textit{put},a,1)$, $\textit{ret}(\textit{put},a)$, $\textit{call}(\textit{rm},a)$ and $\textit{ret}(\textit{rm},a)$.

\begin{restatable}{lemma}{RelateQueuewithPQ}
\label{lemma:relate queue with priority queue}
Given a history $h_q$ of queue operations, $h_q$ is linearizable to queue, if and only if $\textit{UniPriTrans}(h_q) \sqsubseteq \textit{PQueue}$.
\end{restatable}

\begin {proof}

This is obvious, since we already ensure that for each single-priority history $h$, $\textit{transToQueue}(h)$ is linearizable to queue. \qed
\end {proof}


